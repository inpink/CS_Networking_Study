> 네트워크 보안

Dos, 스니핑, sql 삽입 등 다양한 인터넷 보안 공격이 존재한다.　   
이러한 공격으로부터 네트워크를 보호하는 것을 **네트워크 보안**이라고 한다.　   
　   

> "안전한 통신"이란?

1. 기밀성 (송신자와 지정된 수신자만 전송되는 메세지 내용을 이해할 수 있어야 함. 암호화/복호화 사용)　   
2. 메세지 무결성 (메세지가 중간에 변경되지 않았음을 보장한다. 체크섬 등 사용)　   
3. 종단점 인증 (송신자와 수신자는 서로 상대방의 신원을 확인할 수 있어야 함. nonce 등 사용)　   
4. 운영 보안 ( 우리의 네트워크에서 오고 가는 패킷을 제어하고, 관찰하고, 의심스러운 행동은 네트워크 관리자에게 보고한다. 방화벽, IDS, IPS)　   
　   
　   
> 암호화

모든 암호화 알고리즘은, "평문"을 "암호화된 메세지"로 만드는 것이다.　   
대표적인 암호화 알고리즘에는　   
ⓐ대칭키 알고리즘, ⓑ공개키 알고리즘　   
이 있다. 　   
　   
　   
> 대칭키 암호화

A와 B가 암호화 통신을 할 때, 서로 같은 **비밀 키**를 공유한다.　   
이 키를 이용하여 보내는 쪽이 암호화하고, 받는 쪽은 복호화한다.　   
비밀 키가 외부에 공개되거나 해독되면, 안전하지 않을 수 있다.　   
비밀 키를 네트워크를 타고 전송한다면, 이 또한 스니핑 등의 대상이 되어 위험할 수도 있다.　   
직접 만나서 교환하는 것이 안전한 방법일 수 있다.　   
하지만 그러지 못했을 때를 위해 DES, 3DES, AES 등의 해독이 어려운 알고리즘을 이용한다.　   
　   
　   
> 공개키 암호화

"대칭키 암호화"의 비밀 키를 양쪽이 공유해야 하는 어려움을 해결한 방법이다.　   
　   
모두에게 공개된 공개키(public key)와, 복호화 하는 사람만 아는 개인키(private key)를 이용한다. 　   
송신자는 **수신자의 공개키** 를 이용하여 암호화한다. 　   
수신자는 개인키를 이용하여 암호화한다. 　   
이 때, 복호화 알고리즘 또한 알려져있다. 개인키만 비공개인 것이다.　   
　   
공개키 암호화에는 대부분 **RSA 알고리즘** 을 사용한다.　   
RSA는 **모듈로 연산** 을 주로 사용한다. 모듈로 연산은 "나머지"를 이용하는 연산이다.　   
　   
"수신자"는 2개의 큰 소수(prime number) p와 q를 선택한다. 　   
이 값이 클수록 RSA를 해독하기 어렵다. 　   
암호를 해독하기 어렵다는 것은, 유한한 시간 내에 "개인키 없이는" 이 암호를 해독할 수 없다는 것이다.　   
이 값이 클수록 복호화 시간도 더 많이 걸리긴 한다. 개인키가 있기 때문에 불가능한 수준은 아니다.　   
기본적으로 RSA는 다른 암호화 기법보다 더 시간이 많이 걸리지만, 해독이 어렵기에 중요한 보안이 필요한 분야에서는 많이 사용된다.　   
　   
=> 아주 큰 수 p와 q의 곱인 n을 계산하는 것은 그렇게 오랜 시간이 걸리지 않는다.　   
하지만, n으로부터 p와 q를 뽑아내는 **소인수분해**는 매우 오래 걸린다.　   
2048bit 크기의 암호키에서 p와 q를 뽑아내는 해독을 하려면 무려 300조가 걸린다.　   
　   
수신자는 (pq, (p-1)(q-1)와의 서로소)를 공개키로 공개한다. 이를 (n,e)라고 하자. 　   
그리고 "ed%(p-1)(q-1)=1"을 만족하는 d가 **개인키**가 된다.　   
　   
송신자는 공개키를 이용하여  "평문^e % n" 으로 암호화하여 보낸다. 이 암호문을 c라고 하자.　   
수신자는 "c^d%n"를 통해 복호화를 한다. 이 값이 평문이 된다.　   
　   
RSA는 암호화/복호화 알고리즘이 위와 같이 모두 공개되어 있다. 알고리즘 자체가 복잡하지도 않다.　   
**유클리드 호제법**등을 이용하여 구현해주는 것이 어렵지 않다.　   
아래 코드를 참고하자. RSA 구현 방법을 공부할 수 있다.  　   
[Python으로 RSA 구현](https://watchout31337.tistory.com/366)　   
　   
사실 네트워크 보안에서는, TCP에 보안 기능을 향상시킨 **TLS**를 WAS(톰캣같은)에 올려 주로 사용한다. (8.2장에서 배움)　   
특정 이유로 TLS를 사용하지 않을 경우, 평문을 그대로 전송하면 보안 문제가 생길 수 있다.　   
따라서 서버에서 RSA를 이용하여 공개키, 개인키를 생성하고, 클라이언트 쪽 코드에 javascript를 이용하여 암호화한 뒤 서버에 보내주면, 서버에서 개인키를 이용하여 복호화한다.　   
　   
아래 링크에 Spring에서 RSA 암호화를 구현한 방식&코드가 매우 잘 설명되어 있다. 　   
Spring boot를 이용한다면 내장 WAS(Apache Tomcat)를 사용하기에, 웹 서버 통신 설정은 걱정하지 않아도 된다.　   
클라이언트->서버로 보내는 id, pwd를 RSA로 완벽 보안해준다. 　   
사용하는 Library와 전송하고 받는 데이터 형식 등을 주의깊게 보자!　   
[Spring에서 SSL 없이 RSA 암호화](https://jqdom.tistory.com/entry/SSL-%EC%97%86%EC%9D%B4-RSA-%EC%95%94%ED%98%B8%ED%99%94-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%B2%98%EB%A6%AC-Spring-Framework-RSA)　    　   
  　   
WAS, 웹서버 등의 용어가 헷갈린다면 아래 포스팅을 보고 오자! 정리해두었다.   　   
https://blog.naver.com/willyouspeedup/223157843517   　   
   　   
    　   
=> 인증(authentication) 및 전자서명(digital signature)에도 이 공개키 암호화 방식을 사용할 수 있다.　   
　   
　   
![image](https://github.com/inpink/CS_Networking_Study/assets/108166692/47507dc3-13ea-465c-b27e-0648232567ab)　   
이 알고리즘은 큰 수의 소인수분해가 유효 시간 내에 어렵다는 특징을 이용했다.　   
하지만 "양자 컴퓨터" 등을 이용하여 빠른 시간 내에 큰 수의 소인수분해를 해낸다면, 현재 RSA에 의존하는 많은 보안이 위험해지게 될 것이다. 　   

　   
　   
> 암호화 해시 함수

평문 m을, 고정된 크기의 문자열 **해시, H(m)** 로 만들어내는 알고리즘이다.　   
해시 함수로 사용되는 해시 알고리즘에는 MD4, MD5, SHA-1 등이 있다. 　   
(인터넷 체크섬처럼 간단한 해시 알고리즘을 사용한다면 당연히 보안에 문제가 있겠다.)　
 　   
MD5는 128bit의 해시 문자열을 만들어내고, SHA-1은 160bit의 해시 문자열을 만들어낸다.　   
당연히, 해시 문자열 길이가 길 수록 더욱 보안이 견고하지만 암호화/복호화 시간은 더 걸린다.　   

해시 알고리즘에 따른 실행 시간을 비교해둔 사이트는 아래 링크를 참고하자. 　   
https://zetawiki.com/wiki/%ED%95%B4%EC%8B%9C_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%86%8D%EB%8F%84_%EB%B9%84%EA%B5%90 　   
　   
이 방식은 세션 키, 전자 서명, API 키 등에 사용되는데,　   
RSA보다는 덜 견고하지만 시간이 덜 소요되므로, 　   
정말 중요한 보안의 경우 RSA를 사용하고,　   
메세지 전체에 대해 RSA를 하는 경우가 너무 과도한 경우에는 해시 함수 등을 이용할 수 있다.　   
　   
　   
　   
> 종단점 인증(end-point authenticatin)

통신 개체가 다른 개체에게 **자신의 신원을 컴퓨터 네트워크 상으로 증명**하는 것이다. 　   
그 중, 인증 프로토콜 ap4.0은 **넌스(nonce)**를 이용하여 종단점 인증을 한다. 　   
넌스는, 이 프로토콜이 전체를 통틀어 평생 단 한번만 사용하는 숫자를 뜻한다. 일회용 넌스를 사용함으로서 종단점 인증을 할 수 있다. 　   
 　   
 　   
