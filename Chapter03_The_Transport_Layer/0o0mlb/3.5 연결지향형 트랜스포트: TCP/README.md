# 3.5 연결지향형 트랜스포트: TCP
## 3.5.1 TCP 연결
TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스에게 보내기 전에, 두 프로세스가 서로 `핸드셰이크`를 먼저 해야 하므로 **연결 지향형(connection-oriented)**이다.

TCP 연결 설정의 일부로서, 연결의 양단은 TCP 연결과 연관이 많은 TCP 상태 변수를 초기화한다.

TCP `연결`은 종단 간의 TDM, FDM이 아니라 두 통신 종단 시스템의 **TCP에 존재하는 상태를 공유하는 논리적인 것**이다. TCP 프로토콜은 오직 종단 시스템에서만 동작한다

TCP 연결은 **전이중 서비스(full-duplex service)**를 제공한다. 또한 TCP 연결은 항상 단일 송신자와 단일 수신자 사이의 **점대점(point-to-point)**이다. 

### TCP가 동작하는 과정
1. 클라이언트 애플리케이션 프로세스는 서버의 프로세스와 연결을 설정하기를 원한다고 TCP 클라이언트에게 먼저 알린다
2. 클라이언트 트랜스포트 계층은 서버의 TCP와의 TCP 연결 설정을 진행한다: **3-way handshake**
	2-1. 클라이언트는 먼저 특별한 TCP 세그먼트를 보낸다. 페이로드 없음
	2-2. 서버는 두번째 특별한 TCP 세그먼트로 응답한다. 페이로드 없음
	2-3. 클라이언트가 세 번째 특별한 세그먼트로 다시 응답한다. 페이로드 가능
3. 클라이언트 프로세스는 소켓을 통해 데이터의 스트림을 전달한다. 
4. TCP는 버퍼 중 하나인 연결의 **송신 버퍼(send buffer)**로 데이터를 보낸다
5. TCP는 TCP 헤더와 클라이언트 데이터를 하나로 짝지어 **TCP 세그먼트**를 구성한다
6. 세그먼트는 네트워크 계층에 전달되며, 네트워크 계층 IP 데이터 그램 안에 각각 캡슐화된다. 이 세그먼트들은 네트워크로 송신된다
7. 세그먼트의 데이터는 TCP 연결의 **수신 버퍼(receive buffer)**에 위치한다
8. 애플리케이션은 이 버퍼로부터 데이터의 스트림을 읽는다

### MSS
TCP는 `자신이 편한 대로 세그먼트의 데이터를 전송`해야 하며 세그먼트를 모아 담을 수 있는 최대 데이터의 양은 **최대 세그먼트 크기(maximum segment size, MSS)**로 제한한다.

MSS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(**최대 전송 단위(maximum transmission unit, MTU)**에 의해 일단 결정되고, TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다

---
## 3.5.2 TCP 세그먼트 구조
TCP 세그먼트는 `헤더 필드`와 `데이터 필드`로 구성되어 있다

데이터 필드는 애플리케이션 데이터의 일정량을 담는다. MSS는 세그먼트의 데이터 필드의 크기를 제한한다

TCP 세그먼트 헤더는 다음과 같은 필드를 포함한다
- `출발지와 목적지 포트 번호`
- `체크섬 필드`
- `32비트 **순서 번호 (sequence number)** 필드`와 `32비트 **확인응답 번호(acknowledgement number)** 필드`: 신뢰적인 데이터 전송 서비스
- `16비트 **수신 윈도(receive window)** 필드`: 흐름 제어, 수신자가 받아들이려는 바이트의 크기
- `4비트 **헤더 길이(header length)** 필드`: TCP 헤더의 길이로 가변적인 길이가 될 수 있다
- `**옵션** 필드`: 선택적이고 가변적인 길이로 송신자와 수신자가 MSS를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용
- `6비트 **플래그** 필드`: ACK, RST, SYN, FIN, PSH, URG

### 순서 번호와 확인응답 번호
TCP 세그먼트 헤더에서 가장 중요한 필드 두 가지는 `순서 번호 필드`와 `확인응답 번호 필드`다.
이러한 필드들은 TCP의 **신뢰적인 데이터 전송 서비스**의 중대한 부분이다

**세그먼트에 대한 `순서 번호`**는 세그먼트에 있는 `첫 번째` 바이트의 바이트 스트림 번호다.
각각의 순서 번호는 적절한 TCP 세그먼트의 헤더 내부의 순서 번호 필드에 삽입된다

송신 호스트가 자신의 세그먼트에 삽입하는 `확인응답 번호`는 송신 호스트가 수신 호스트로부터 기대하는 `다음 바이트의 순서 번호`다

중간에 잃어버린 세그먼트 때문에 기다리는 바이트가 도착하지 않는다면 TCP는 **누적 확인응답**을 제공한다

---
## 3.5.3 왕복 시간(RTT) 예측과 타임아웃
TCP가 손실 세그먼트를 발견하기 위해 타임아웃/재전송 메커니즘을 사용한다. 이때 `타임아웃 주기`가 불분명하다

`타임아웃`은 세그먼트가 전송된 시간부터 긍정 확인응답될 때까지의 시간인 연결의 왕복시간(**RTT**)보다 좀 커야 한다

### 왕복 시간 예측
`SampleRTT`란 세그먼트에 대한 RTT 샘플은 세그먼트가 송신된 시간으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 시간 길이다
- 전송되었지만 현재까지 확인응답이 없는 세그먼트 중 하나에 대해서만 측정
- 왕복 시간마다 SampleRTT의 새로운 값을 얻는다
- 재전송한 세그먼트에 대한 SampleRTT는 계산하지 않는다
- 한 번 전송된 세그먼트에 대해서만 측정한다

TCP는 SampleRTT 값의 평균 `EstimatedRTT`을 유지한다
```
EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT
```
즉, EstimatedRTT의 새로운 값은 EstimatedRTT의 이전 값과 SampleRTT에 대한 새로운 값의 가중된 조합이다. EstimatedRTT는 SampleRTT의 가중평균으로 최근 샘플에 높은 가중치를 준다

`DevRTT`는 RTT의 변화율을 의미한다

### 재전송 타임아웃 주기의 설정과 관리
TCP 타임아웃값은 EstimatedRTT에 약간의 여윳값을 더한 값을 설정하는 것이 바람직하다

SampleRTT값에 많은 변동이 있으면 여윳값이 커야 하며, 변동이 작을 때는 작아야한다. DevRTT가 이러한 여윳값의 역할을 하게 된다

```
TimeoutInterval = EstimatedRTT + 4*DevRTT
```

---
## 3.5.4 신뢰적인 데이터 전송
TCP는 IP의 비신뢰적인 최선형 서비스에서 **신뢰적인 데이터 전송 서비스**를 제공한다

TCP의 신뢰적인 데이터 전송 서비스는 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으며 손실이나 중복이 없다는 것과 순서가 유지된다는 것을 보장한다

1. 주요 이벤트 발생
TCP 세그먼트는 첫 번째 데이터 바이트의 바이트 열 번호인 순서 번호를 포함한다.
그리고 세그먼트를 IP로 넘길 때 타이머를 시작한다

2. 타임아웃
TCP는 타임아웃을 일으킨 세그먼트를 재전송하여 응답한다

3. 수신자로부터의 수신 확인응답 세그먼트(ACK) 수신
TCP는 누적 확인응답을 사용하고, y는 y바이트 이전의 모든 바이스의 수신을 확인한다

이때 문제가 발생한다
- 손실된 확인응답에 기인하는 재전송
- 두번째 세그먼트가 재전송되지 않는 경우
- 누적 확인응답은 첫 번째 세그먼트의 재전송을 방지한다

### 타임아웃 주기의 두 배로 설정
`타임아웃 주기`의 길이를 타임아웃이 발생할 때마다 TCP는 아직 확인응답이 안 된 가장 작은 순서 번호를 가진 세그먼트를 재전송한다

그러나 TCP는 재전송 때마다 타임아웃 주기를 `이전 값의 두 배`로 설정한다

### 빠른 재전송
타임아웃이 유발하는 재전송의 한 가지 문제는 타임아웃의 주기가 때때로 `비교적 길다`는 점이다

세그먼트를 잃었을 때, 긴 타임아웃 주기는 송신자를 오랫동안 기다리게 해서 `종단 간의 지연`을 증가시킨다

**중복 ACK**는 송신자가 이미 이전에 받은 확인응답에 대한 `재확인응답` 세그먼트 ACK다.

중복 ACK는 이런 상황에서 발생한다.

TCP 수신자는 기다리는 다음 것보다 더 큰 순서 번호를 가진 세그먼트를 받았을 때, 수신자는 **마지막으로 수신된 순차적인 바이트**를 갖는 데이터를 다시 확인응답을 한다

송신자는 종종 많은 양의 세그먼트를 연속적으로 보낼 수 있으므로, 많은 연속적인 중복 ACK가 존재할 수 있다

만약 TCP 송신자가 같은 데이터에 대해 `3개의 중복 확인 응답`을 수신한다면, TCP는 세그먼트의 `타이머가 만료되기 이전에` 손실 세그먼트를 재전송하는 **빠른 재전송(fast retransmit)**를 한다

### GBN인가 SR인가?
TCP 확인응답은 누적되고 올바르게 수신되지만, 순서가 잘못된 세그먼트는 수신자가 개별적으로 ACK을 받지 않는다

TCP 송신자는 전송했지만 확인응답 안 된 바이트의 `가장 작은 순서 번호`와 `전송될 다음 바이트의 순서 번호`를 유지해야 한다

TCP 수신자는 마지막으로 `순서가 틀린` 세그먼트에 대해 선택적으로 학인응답을 하게 한다

이는 TCP의 오류 복구 메커니즘은 GBN과 SR 프로토콜의 혼합으로 분류하는 것이 적당하다

---
## 3.5.5 흐름 제어
TCP 연결이 순서대로 올바르게 바이트에 수신할 때 TCP는 데이터를 수신 버퍼에 저장한다.
애플리케이션이 데이터를 읽는 속도가 비교적 느리다면, 송신자가 점점 더 많은 데이터를 빠르게 전송함으로써 연결의 수신 버퍼에 아주 쉽게 **오퍼플로를 발생시킨다**

TCP는 송신자가 수신자의 버퍼를 오버플로시키는 것을 방지하지 위해 애플리케이션에게 `흐름 제어 `서비스를 제공한다.

즉, 흐름 제어는 **속도를 일치**시키는 서비스다. 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다

### 수신 윈도, rwnd
TCP는 송신자가 `수신 윈도(receive window), rwnd`라는 변수를 유지하여 흐름 제어를 제공한다.
수신 윈도는 수신 측에서 **가용한 버퍼 공간이 얼마나 되는지**를 송신자에게 알려주는데 사용된다

TCP는 전이중(full-duplex)이므로 연결의 각 측의 송신자는 별개의 수신 윈도를 유지한다

수신 호스트는 송신 호스트에게 전송하는 모든 세그먼트의 **윈도 필드**에 현재 `rwnd 값`을 설정함으로써 **연결 버퍼에 얼마만큼의 여유 공간이 있는지**를 송신 호스트에게 알려준다

송신 호스트가 rwnd의 값보다 작은 확인응답이 안 된 데이터의 양을 유지함으로써 수신 버퍼에 오버플로가 발생하지 않는다는 것을 확신한다

### rwnd = 0
호스트의 수신 버퍼가 `rwnd = 0`으로서 가득 차서 송신 호스트에게 rwnd = 0이라고 알리고 전송할 게 없다고 한다면 어떤 문제가 발생할까?
- 수신 호스트에서의 애플리케이션 프로세스가 버퍼를 비우더라도, TCP는 송신 호스트에게 새로운 rwnd로 새로운 세그먼트를 전송하지 않는다
- TCP는 전송할 데이터가 있거나 전송해야 할 확인응답(ACK)을 가진 경우에만 세그먼트를 전송하기 때문에, 송신 호스트는 약간의 공간이 있다는 것을 모른다
- 송신 호스트는 차단되고 더는 데이터를 전송할 수 없다

이렇듯 rwnd = 0 일때, TCP 명세서는 `1바이트 데이터`로 세그먼트를 계속해서 전송하도록 요구한다. 만약 약간의 공간이 있다면 긍정 확인응답이 될 것이다

---
## 3.5.6 TCP 연결 관리
SYN 플러드 공격을 비롯한 가장 일반적인 네트워크 공격은 대부분 `TCP 연결 관리의 취약점`을 악용한다

### TCP 연결: 3-way handshake
클라이언트 안의 TCP가 서버와 TCP 연결을 설정하는 방법은 다음과 같다

1단계. 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신한다

이 세그먼트는 애플리케이션 계층 데이터를 포함하지 않고, 세그먼트의 헤더에 `SYN 비트`라고 불리는 하나의 플래그 비트를 `1`로 설정한다. 이를 `SYN 세그먼트`라고 부른다

또한 클라이언트는 `최초의 순서 번호(client_isn)`를 임의로 선택하고, 최초의 TCP SYN 세그먼트의 순서 번호 필드에 이 번호를 넣는다

2단계. TCP SYN 세그먼트를 포함하는 IP 데이터그램이 서버 호스트에 도착하면, 서버는 데이터그램으로부터 `TCP SYN 세그먼트`를 추출한다

그리고 연결에 TCP 버퍼와 변수를 할당하고, 클라이언트 TCP로 `연결 승인 세그먼트`를 송신한다.
연결 승인 세그먼트도 애플리케이션 계층 데이터를 포함하지 않는다. 이는 **연결 설정에 동의**한다는 의미이다. 때때로 `SYNACK 세그먼트`로도 불린다

세그먼트 헤더 안에 3개의 중요한 정보를 포함한다
1. SYN 비트는 1로 설정된다
2. TCP 세그먼트 헤더의 확인응답 필드는 `client_isn+1`로 설정된다
3. 서버는 자신의 `최초의 순서 번호(server_isn)`를 선택하고, TCP 세그먼트 헤더의 순서 번호 필드에 이 값을 넣는다

3단계. 연결 승인 세그먼트를 수신하면, 클라이언트는 연결에 버퍼와 변수를 할당한다

클라이언트 호스트는 서버로 또 다른 세그먼트를 송신하여 서버의 연결 승인 세그먼트를 확인하는 의미로 클라이언트는 TCP 세그먼트 헤더의 확인응답 필드 안에 `server_isn+1` 값을 넣는다

연결이 설정되었기 때문에 SYN 비트는 `0`으로 설정된다. 이때는 데이터를 세그먼트 페이로드에서 운반할 수 있다

이러한 TCP 연결 설정 절차를 **3-way handshake**라고 부른다

### TCP 연결 종료
1. 클라이언트가 연결 종료를 결정한다면, 클라이언트 애플리케이션 프로세스는 종료 명령을 내리고, 이것은 클라이언트 TCP가 서버 프로세스에게 특별한 TCP 세그먼트를 보내도록 한다

> 이 특별한 세그먼트는 `1`로 설정된 `FIN 비트`라고 불리는 플래그 비트를 세그먼트 헤더에 포함하고 있다

2. 서버가 이 세그먼트를 수신하면, 서버는 클라이언트에게 확인응답 세그먼트(ACK)를 보낸다
3. FIN 비트가 1로 설정된 자신의 종료 세그먼트를 송신한다
4. 클라이언트는 서버의 종료 세그먼트에 확인응답(ACK)을 한다
5. 대기시간을 가진 후, 두 호스트의 모든 자원은 할당이 해제된다

TCP 연결이 존재하는 동안 각 호스트에서 동작하는 TCP 프로토콜은 다양한 **TCP 상태**를 두루 전이한다
