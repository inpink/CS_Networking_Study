# 3.4 신뢰적인 데이터 전송의 원리
서비스 추상화를 구현하는 것이 **신뢰적인 데이터 전송 프로토콜**의 의무다. 
이 작업은 신뢰적인 전송 프로토콜의 `아래에 있는` 계층이 신뢰적이지 않을 수 있어서 어려워진다

- 하위 채널에서 비트가 손상되는 경우
- 하위 채널에서 전체 패킷이 손실하는 경우

하위 채널은 패킷의 순서를 바꾸지 않고 **단방향 데이터 전송**의 경우인 송신 측으로부터 수신 측까지의 데이터 전송만을 고려한다

## 3.4.1 신뢰적인 데이터 전송 프로토콜의 구축
### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송: rdt1.0
하위 채널이 `완전히 신뢰적인` 가장 간단한 경우, 프로토콜 자체를 `rdt1.0`이라 한다

rbt1.0 송신 측은 상위 계층으로부터 데이터를 받아들이고 데이터를 포함한 패킷을 생성한다.
이후, 패킷을 채널로 송신한다

rbt1.0 수신 측은 하위의 채널로부터 패킷을 수신하고, 패킷으로부터 데이터를 추출한 후 데이터를 상위 계층으로 전달한다

### 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송: rdt2.0
패킷 안의 비트들이 하위 채널에서 `손상`되는 모델을 `rdt2.0`이라 한다

비트 오류는 패킷이 전송 또는 전파되거나 버퍼링될 때 네트워크의 물리적 구성요소에서 일반적으로 발생한다

**긍정 확인응답**과 **부정 확인응답**을 둘 다 사용하고 **자동 재전송 요구 프로토콜**을 통해 `재전송`을 기반으로 한다

`비트 오류`를 처리하기 위해 기본적으로 3가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다
1. `오류 검출`
송신자로부터 수신자에게 전송되는 추가적인 비트들이 요구된다.
해당 비트들은 rdt2.0 데이터 패킷의 `패킷 체크섬` 필드로 모아진다
2. `수신자 피드백`
수신자가 송신자에게 피드백을 제공하여 도착 여부를 체크한다.
rdt2.0 프로토콜은 수신자로부터 송신자 쪽으로 **ACK**(긍정 확인응답) 과 **NAK**(부정 확인응답) 패킷들을 전송한다
해당 패킷은 단지 `한 비트` 길이면 된다. 0 값은 NAK을 의미하고, 1 값은 ACK을 의미할 수 있다
3. `재전송`
수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송된다

rdt2.0 송신 측은 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷을 생성하고, 그 패킷을 전송한다. 또한, 수신자로부터의 ACK 또는 NAK 패킷을 기다린다
- 만약 ACK 패킷이 수신된다면, 가장 최근에 전송된 패킷이 정확하게 수신되었음을 알게 된다
- 만약 NAK 패킷이 수신된다면, 프로토콜은 마지막 패킷을 재전송하고 재전송된 패킷에 대한 응답을 기다린다

송신자는 수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지 새로운 데이터를 전달하지 않을 것이다. 이 때문에, rdt2.0 프로토콜은 **전송 후 대기** 프로토콜이다

rdt2.0 수신 측은 수신도니 패킷이 손상되었는지 아닌지에 따라 ACK 또는 NAK로 응답한다

### 손상된 ACK 또는 NAK를 처리하기 위한 방법
데이터 패킷에 새로운 필드를 추가하고 송신자가 이 필드 안에 **순서 번호**를 붙이는 방법이다

수신자는 순서 번호를 통해 재전송한 것 인지 새로운 패킷을 전송한 것인지 판단할 수 있고

송신자는 수신된 ACK와 NAK 패킷이 가장 최근에 전송된 데이터 패킷에 대한 응답으로 발생한 것임을 안다

- 순서가 바뀐 패킷이 수신되면, 수신자는 이미 전에 수신한 패킷에 대한 긍정 확인응답을 전송한다
- 손상된 패킷이 수신되면, 수신자는 부정 확인응답을 전송한다. NAK 대신에 `가장 최근에 정확하게 수신된 패킷에 대해 ACK`을 송신하여 NAK를 송신하는 것과 같은 효과를 얻는다
- 같은 패킷에 대해 2개의 ACK를 수신하면, 송신자는 수신자가 두 번 ACK 한 패킷의 다음 패킷을 정확하게 수신하지 못했음을 안다

### NAK 없는 신뢰적인 데이터 전송: rdt2.2
송신자는 수신된 ACK 메시지에 의해 확인응답된 `패킷의 순서 번호`를 반드시 검사해야만 한다

### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송: rdt3.0
비트가 손상될 뿐만 아니라 `패킷을 손실`하는 경우 수신자로부터 어떠한 응답도 없다

재전송을 하기 위해, 주어진 시간이 지난 후에 송신자를 인터럽트(중단)할 수 있는 **카운트다운 타이머**가 필요하다

송신자는 다음과 같이 동작해야 한다
1. 새로운 패킷이나 재전송 패킷이 송신된 시간에 타이머를 시작함
2. 타이머 인터럽트에 반응함
3. 타이머를 멈춤

패킷 순서 번호가 0과 1이 번갈아 일어나므로, 프로토콜 rdt3.0은 **얼티네이팅 비트 프로토콜**이라고 부른다

### 신뢰적으로 동작하는 데이터 전송 프로토콜
데이터 전송 프로토콜의 주요 구성 요소는`체크섬`, `순서 번호`, `타이머`, `긍정 확인응답(ACK)`, `부정 확인응답(NAK)` 등으로 프로토콜 동작에서 중요한 필수 임무를 수행한다

---
## 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜
rdt3.0의 핵심적인 성능 문제는 `전송 후 대기(stop-and-wait)`프로토콜이라는 점이다

전송 후 대기 방식으로 동작하는 대신에 송신자에게 확인응답을 기다리지 ㅇ낳고 **여러 패킷을 전송**하도록 허용하는 것이다

많은 전송 중인 송신자-수신자 패킷을 파이프라인에 채워 넣는 기술을 `파이프라이닝(pipelining)`이라고 부른다

파이프라이닝 방식은 신뢰적인 데이터 전송 프로토콜에서 중요성을 가지고 있다
- 순서 번호의 범위가 커져야 한다. 각각의 전송 중인 패킷은 유일한 순서 번호를 가져야 하고 ACK가 안 된 패킷이 여럿 있을지도 모른다
- 프로토콜의 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야 한다. 송신자는 전송되었으나 확인응답되지 않은 패킷을 버퍼링해야 한다
- 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷, 손상 패킷, 상당히 지연된 패킷들에 대해 응답하는 방식이 달려 있다. `GBN`과 `SR`등의 오류 회복 방식이 있다

---
## 3.4.3 GBN
GBN(Go-Back-N) 프로토콜에서 송신자는 **확인응답을 기다리지 않고 여러 패킷**을 전송할 수 있다.
그러나 파이프라인에서 확인응답이 안 된 패킷의 `최대 허용 수 N`보다 크지 말아야 한다

확인응답이 안 된 패킷을 위해 허용할 수 있는 순서 번호의 범위는 크기가 N인 `윈도`로 나타낸다. 

프로토콜이 동작할 때, 이 윈도는 순서 번호 공간에서 **오른쪽으로 이동**된다. N을 `윈도 크기`라 부르며, GBN 프로토콜은 **슬라이딩 윈도 프로토콜**이라고 부른다

GBN 송신자는 세 가지 타입의 이벤트에 반응해야 한다

1. 상위로부터 호출: `rdt_send()`가 위로부터 호출되면, 송신자는 우선 윈도가 가득 찼는지, 즉 N개의 아직 확인응답되지 않은 패킷이 있는지를 확인한다
- 윈도가 가득 차 있지 않다면, 패킷이 생성되고 송신된다
- 윈도가 가득 차 있다면, 송신자는 데이터를 상위 계층으로 반환한다

2. ACK의 수신: GBN 프로토콜에서 순서 번호 `n`을 가진 패킷에 대한 확인응답은 **누적 확인응답**으로 인식된다. 이는 n까지의 순서 번호를 가진 **모든 패킷**에 대한 확인응답이다

3. 타임아웃 이벤트: 만약 타임아웃이 발생한다면, 송신자는 이전에 전송되었지만 아직 확인응답되지 않은 모든 패킷을 **다시 송신**한다

GBN 수신자의 행동은 단순하다
- 순서 번호 n을 가진 패킷이 오류 없이 순서대로 수신된다면, 수신자는 패킷 n에 대한 ACK을 송신하고 상위 계층에 패킷의 데이터를 전달한다
- 패킷이 오류가 있거나 순서대로 수신되지 않는다면, 수신자는 그 패킷을 버리고 **가장 최근에** 제대로 수신된 순서의 패킷에 대한 ACK를 **재전송**한다

---
## 3.4.4 SR
SR 프로토콜은 수신자에게 오류가 발생한 패킷을 수신했다고 의심되는 패킷만을 송신자가 다시 전송하므로 불필요한 재전송을 피한다.
개별적인 재전송은 수신자가 올바르게 수신된 패킷에 대한 **개별적인**확인응답을 요구할 것이다

SR 송신자의 이벤트와 행동은 다음과 같다

1. 상위로부터 데이터 수신: SR 송신자는 패킷의 다음 순서 번호를 검사한다. 순서 번호가 송신자 윈도 내에 있으면 데이터는 패킷으로 송신되고, 아니면 버퍼에 나중에 전송하기 위해 되돌려진다
2. 타임아웃: 타임아웃 시 **오직 한 패킷만**이 전송되기 때문에, 각 패킷은 자신의 논리 타이머가 있어야 한다.
3. ACK 수신: ACK가 수신되었을 때, SR 송신자는 그 ACK가 윈도 내에 있다면 그 패킷을 수신된 것으로 표기한다. 패킷 순서 번호가 send_base와 같다면, 윈도 베이스는 가장 작은 순서 번호를 가진 아직 확인응답되지 않은 패킷으로 옮겨진다. 만약 윈도가 이동하고 미전송 패킷이 있다면, 이 패킷들은 전송된다

SR 수신자의 이벤트와 행동은 다음과 같다

1. [rcv_base, rcv_base+N-1] 내의 순서 번호를 가진 패킷이 손상 없이 수신된다
2. [rcv_base-N, rcv_base-1] 내의 순서 번호를 가진 패킷이 수신된다. 이미 수신된 패킷을 무시하지 않고 재확인응답을 한다. 왜냐하면 새로운 전송인지 재전송인지 파악하기 위해서이다
3. 그 외의 경우, 패킷을 무시한다
