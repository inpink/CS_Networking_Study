> 목차

👉[3.3 비연결형 트랜스포트 UDP](#33-비연결형-트랜스포트-UDP)　   
　   [3.3.1 UDP 세그먼트 구조](#331-UDP-세그먼트-구조)　   　   
　   [3.3.2 UDP 체크섬](#332-UDP-체크섬)　   
  
　   
　   

## 3.3 비연결형 트랜스포트 UDP

UDP (Uder Datagram Protocol)는　   
TCP와 다르게 핸드셰이크를 수행하지 않는다. (비연결지향)　   
　   
많은 애플리케이션은 의외로 TCP보다 UDP가 더 적합하다. 　   
　   
　   
> UDP 특징

TCP와의 차이점으로도 볼 수 있다.　   
1. 애플리케이션 계층(5)에서 더 정교한 제어를 할 수 있다. (커스터마이징 가능)　   
2. TCP 기능 중 원하지 않는 기능이 있을 경우 UDP를 사용하면 좋다. 　   
3. 조금의 데이터 손실은 허용되는 경우, 더 빠른 속도로 전송할 수 있다.　   
4. TCP는 네트워크 혼잡 상태에 따라 아주 느리게 전송률이 제어될 수도 있다. UDP는 우리의 애플리케이션에 대해 최소 전송률을 요구할 수 있다.　   
5. 연결 상태를 유지하지 않는다. 도착한 세그먼트의 파라미터 중 어떤 것도 저장하지 않는다. 따라서, 같은 자원으로 더 많은 클라이언트를 받을 수 있다.　   
6. TCP는 세그먼트 당 20Byte의 헤더를 가진다. UDP는 8Byte이다. 더 작은 메모리를 소요한다.　   
　   
![image](https://github.com/inpink/CS_Networking_Study/assets/108166692/032a0c19-4b6c-4c2a-9d0a-0ea2cd3b8995)
　   
　   
> UDP의 혼잡 제어

UDP는 TCP와 다르게 혼잡 제어 기능을 제공하지 않는다.　   
UDP는 우리의 애플리케이션에 대해 최소 전송률을 요구할 수 있다.　   
하지만, 혼잡 제어는 전체적인 네트워크를 봤을 때 꼭 필요하다.　   
혼잡 제어가 없다면, 라우터 큐에 많은 패킷이 쌓이게 될 것이며, 패킷 손실률이 높아져 데이터 전송이 원활하게 되지 않는다.　   
QUIC(3.8절)처럼, "애플리케이션 계층(5)"에서 혼잡 제어 기능을 담당하는 등의 방법으로 해결 가능하다.　   
　   
　   
### 3.3.1 UDP 세그먼트 구조

> UDP 세그먼트

아래와 같은 단 4개만의 **field**를 갖는다.　   
1) 출발지 포트 번호 2Byte　   
2) 목적지 포트 번호 2Byte　   
3) UDP 세그먼트 총 길이  2Byte　   
4) 체크섬(checksum)  2Byte　   
　   
추가로 애플리케이션(5)의 데이터(메세지)를 담고 있다.　   
　   
![image](https://github.com/inpink/CS_Networking_Study/assets/108166692/ba278de7-e1ea-4487-95fe-7045cfe5b4fc)
　   
　   
　   
### 3.3.2 UDP 체크섬

오류 검출을 위한 체크섬(checksum)　   
UDP 세그먼트 안의 "비트"에 바뀐 부분이 있는지 없는지 검사할 때 사용한다. 　   
　   
[수신 측]　   
1. 모든 16비트 워드를 합산한다. (합산 시, 발생하는 오버플로는 윤회식 자리올림(wrap around)를 한다)　   
2. 합에 대해 1의 보수를 적용한다. 이 값이 "체크섬"이 된다.　   
　   
[송신 측]　   
1. 모든 16비트 워드를 합산한다. (합산 시, 발생하는 오버플로는 윤회식 자리올림(wrap around)를 한다)　   
2. 체크섬을 더한다. 1111111111111111 이 나오면 문제가 없는 것이다. (1의 보수를 이용했기 때문에)　   
　   
　   
> UDP에서 오류 검출을 하는 이유

일종의 안전장치이다.　   
전송 계층(4)의 모든 하위 계층에서 오류 검사를 제공한다는 보장이 없기 때문이다.  IP(3)만해도 비신뢰적인 프로토콜이다. 　   
　   
　   
> UDP에는 오류 알림, 회복 기능 등이 없다

UDP는 오류 검출을 하지만, 　   
오류가 있다고 알려주거나, 회복해주는 기능은 없다. 검출만 하고 아무 것도 하지 않는다. (헤더 필드만 봐도, 오류가 발생했는지 아닌지 알려주는 필드가 없음)　   
필요할 경우 개발자가 구현해주면 된다.　   
