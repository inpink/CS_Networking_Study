> 목차

👉[3.2 다중화와 역다중화](#32-다중화와-역다중화)　   

　   
　   

## 3.2 다중화와 역다중화
　   
  　   
> 전송 계층(4)에서의 다중화(multiplexing)

전송 계층 프로토콜(4, 프로세스 to 프로세스)를 　   
네트워크 계층 프로토콜(3, 호스트 to 호스트)로　   
전달할 수 있도록 "확장"하는 것　   
　   
소켓(5)으로부터 데이터를 받아서 헤더를 달고, 세그먼트를 생성하고, 캡슐화하여 3계층으로 전달하는 것　   
　   
　   
> 전송 계층(4)에서의 역다중화(multiplexing)

전송 계층 프로토콜(4) -> 애플리케이션 계층 프로토콜(5)　   
　   
수신 측 전송 계층(4)에서 세그먼트를 받았을 때, 이를 애플리케이션 계층(5)으로 전달해야 한다.　   
이 때, 5계층으로 직접 전달하는 것이 아니라 "소켓"을 이용한다. 　   
하나의 컴퓨터(호스트)에는 여러 개의 "소켓"이 있다.　   
　   
수신 측 전송 계층(4)에서는 "소켓 식별자 필드"를 검사하여 적절한 소켓으로 보내준다.　   
TCP인지 UDP인지에 따라 식별자의 포맷은 달라진다. 　   
　   
　   
　   
> 다중화&역다중화

모든 컴퓨터 네트워크에서 필요한 과정이다.　   
　   
세그먼트에는 다중화&역다중화를 위해　   
16비트의 "출발지 포트 번호 필드(source port number field)"와 　   
16비트의 "목적지 포트 번호 필드(destination port number field)"가 있다. 　   
　   
0~1023까지의 포트 번호는 유명한 포트 번호로, 유명한 애플리케이션 프로토콜에서 사용할 수 있도록 엄격히 제한되고 있다.　   
예) HTTP(포트 번호 80번), FTP(포트 번호 21번)　   
　   
모든 네트워크를 이용하는 애플리케이션은 포트 번호를 할당받아야 한다.　   
　   
"출발지 포트 번호"는 회신할 때 이용된다.　   
　   
　   
> 소켓 & 포트

"소켓"은 특정 포트에서 데이터를 송수신하는 인터페이스이다.　   
"포트 번호"는 프로세스에 할당된 번호이다.　   
　   
　   
> 포트 스캐닝

(서버) 프로세스는 클라이언트의 접속을 기다리며 항시 "포트"를 열어둔다. 이를 "열린 포트(open port)"라고 한다.　   
공격자는 해당 서버에 어떤 포트가 열려있는지 스캐닝한다. 　   
스캐닝 방법은 어렵지 않다. 순차적으로 포트를 스캔해서, 전송된 UDP 세그먼트에 반응하면 열려있는 것을 쉽게 알 수 있기 때문이다.　   
공격자가 쉽게 공격할 수 있는 애플리케이션이 열려있다는 것을 포트가 열린 것을 통해 확인하면, 쉽게 공격에 노출된다.　   
예를 들어, SQL 서버는 1434번 포트를 이용하는데, SQL은 웜에 취약하다. 임의의 SQL 코드를 전송하여 공격을 시도할 수 있다.　   
(물론, 공격적인 코드가 서버에 영향을 주지 않도록 서버측에서 보안을 해둘 것이다)　   
　   
　   
　   
> UDP & TCP에서의 다중화&역다중화

UDP : 출발지 IP 주소, 출발지 포트 번호는 검사하지 않는다. "목적지 IP 주소, 목적지 포트 주소" 2가지만 같으면 소켓에서 받는다.　   
TCP : "출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 주소" 4가지가 같아야 소켓에서 받는다. 　   
　   
　   
> UDP가 제공하는 유일한 2가지 서비스

1. 다중화 & 역다중화　   
2. 오류 검출 (헤더에 "오류 검출 필드"를 포함함으로써 "무결성 검사"를 함)　   
오류를 검출만 할 뿐이지, 수정해주지는 않는다.　   
(개발자가 UDP위에 기능을 개발해두면 수정해줄 수도 있다.)　   
　   
UDP는 흔히 "빈 도화지"라고 불린다. 　   
필수적인 통신을 위한 적은 기능만을 제공한다.　   
따라서 TCP에 비해 속도가 빠르며, 개발자가 원하는대로 기능을 추가하여 커스터마이징 할 수 있다.　   
비신뢰성이기 때문에, 신뢰할 수 있도록 검증 서비스를 따로 추가하거나, 애플리케이션 계층(5)에서 추가하지 않는다면(예-QUIC, 3.8절), 데이터가 손실될 가능성이 있다.
　   
　   
　   
> TCP

네트워크 계층(3,IP)의 "비신뢰적인" 서비스를 "신뢰적인 전송 서비스"로 만들어준다. 　   
"혼잡 제어"를 통해, 개별이 아니라 "전체"를 위한 서비스를 제공한다. 　   
　   
UDP에 비해 복잡할 수밖에 없다.　   
"신뢰성, 연결지향, 혼잡 제어"를 위해 반드시 거쳐야 하는 수많은 과정이 존재하며, 정해진 틀이 있다. 　   
　   
TCP&UDP는 3.3절에서 더 자세히 알아본다.　   
　   
　   
> TCP의 **혼잡 제어**

통신에 참여하는 모든 호스트들에게 "공평하게 대역폭을 공유"할 수 있도록 제어하는 것이다. 　   
TCP가 네트워크에 보내는 "트래픽양"을 조절하는 것이다.　   
　   
　   
　   
> 웹 서버와 TCP

오늘날의 많은 웹 서버는 "하나의 프로세스만" 이용한다.　   
하나의 프로세스인데 어떻게 수많은 클라이언트들의 연결을 받을 수 있을까?　   
수 많은 "소켓"을 이용한다. 각 소켓은 "스레스(작은 서브 프로세스)"를 가진다.　   
　   
만약 "지속적"인 연결(웹이니까 HTTP)을 이용한다면,  서버는 **같은 소켓**을 이용해서 HTTP 메세지를 지속적으로 주고 받는다.　   
"비지속적"인 연결을 이용한다면, **매번 새로운 소켓이 생성되고 종료**된다. 이는 웹 서버 성능에 매우 큰 부담을 줄 수 있다.　   
