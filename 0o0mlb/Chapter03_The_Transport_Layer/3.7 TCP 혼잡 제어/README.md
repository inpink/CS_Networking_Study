# 3.7 TCP 혼잡 제어
전통적인 TCP는 네트워크 지원 혼잡 제어보다는 종단 간의 혼잡 제어를 사용한다

## 3.7.1 전통적인 TCP의 혼잡 제어
TCP가 취한 접근 방식은 네트워크 혼잡에 따라 연결에 트래픽을 보내는 전송률을 **각 송신자가 제한**하도록 하는 것이다
- TCP 송신자가 경로에서 혼잡이 없음을 감지하면, 송신자는 송신율을 높인다
- 송신자가 경로에서 혼잡을 감지하면, 송신자는 송신율을 줄인다

의문1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽 전송률을 어떻게 제한하는가?
의문2. TCP 송신자는 자신과 목적지 사이의 경로의 혼잡을 어떻게 감지하는가?
의문3. 송신자는 종단 간의 혼잡을 감지함에 따라 송신율을 변화시키기 위해 어떤 알고리즘을 사용해야 하는가?

### TCP 송신자가 연결로 트래픽을 보내는 전송률 제한
송신 측에서 동작하는 TCP 혼잡 제어 메커니즘은 추가적인 변수인 `혼잡 윈도(congestion window)`를 추적한다

cwnd인 혼잡 윈도는 **TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 속도에 제약을 가한다**. 송신자에서 확인응답이 안 된 데이터 크기를 제한하고 크에 따라 송신자의 송신 속도를 간접 제한한다

대략 매 왕복 시간(RTT)의 시작 때, 송신자는 `cwnd 바이트`만큼의 데이터를 전송할 수 있고, RTT가 끝나는 시점에 데이터에 대한 확인응답을 수신한다

그러므로 송신자의 송신 속도는 대략 `cwnd/RTT 바이트/초`이다. cwnd의 값을 조절하여 송신자는 **링크에 데이터를 전송하는 속도를 조절할 수 있다**

### TCP 송신자가 자신과 목적지 사이의 경로의 혼잡 감지
과도한 혼잡이 발생하면, 경로에 있는 하나 이상의 라우터 버퍼들이 오버플로되고, 그 결과 데이터그램이 버려진다.

버려진 데이터 그램은 송신 측에서 `손실 이벤트` (타임아웃이나 3개의 중복된 ACK의 수신)를 발생시키고, 송신자는 송신자와 수신자 사이의 경로상의 혼잡이 발생했음을 알게 된다

### 손실 이벤트가 발생하지 않는 네트워크가 혼잡이 없는 경우
확인응답이 안된 세그먼트들에 대한 확인응답들이 TCP 송신자에서 수신된다

TCP는 **혼잡 윈도 크기를 증가**시키기 위해 확인응답을 사용한다

- 확인 응답이 상대적으로 늦은 속도로 도착한다면, 혼잡 윈도는 상대적으로 낮은 속도로 증가
- 확인 응답이 높은 속도로 도착한다면, 혼잡 윈도는 더 빨리 증가

TCP는 `확인응답`을 `혼잡 윈도 크기의 증가`를 유발하는 트리거 또는 클록으로 사용하므로, TCP는 **자체 클로킹**이라고 한다

### TCP 송신자가 자신의 송신할 속도 결정
- 손실된 세그먼트는 혼잡을 의미하며, 이에 따라 TCP 전송률은 한 세그먼트를 손실했을 때 줄여야 한다. TCP 송신자는 `혼잡 윈도 크기`와 `손실 이벤트`에 대응하는 전송률을 줄인다
- 확인응답된 세그먼트는 네트워크가 송신자의 세그먼트를 수신자에게 전송된다는 것이고, 이에 따라 이전에 확인응답되지 않은 세그먼트에 대해 ACK가 도착하면 송신자의 전송률은 증가할 수 있다
- 대역폭 탐색. TCP 송신자는 혼잡이 발생하는 시점까지 **전송률을 증가**시키고, 그 시점 이후로부터는 줄인 후, 다시 혼잡 시작이 발생했는지 탐색을 시작한다

**TCP 혼잡 제어 알고리즘**은 `슬로 스타트`, `혼잡 회피`, `빠른 회복`의 구성요소를 가진다
### 슬로 스타트
TCP 연결이 시작될 때, cwnd의 값은 일반적으로 `1MSS`로 초기화되고, 그 결과 초기 전송률은 대략 MSS/RTT가 된다

TCP 송신자에게 가용 대역폭은 MSS/RTT보다 훨씬 클 것이고, TCP 송신자는 가용 대역폭 양을 찾고자 한다.

TCP 전송률은 작은 값으로 시작하지만 슬로 스타트 단계 동안에 **지수적으로 증가**하게 된다

지수적 증가는 언제 끝나는가?
- 타임아웃으로 표시되는 손실 이벤트(혼잡)가 있을 경우, TCP 송신자는 cwnd 값을 `1`로 설정하고 새로운 슬로 스타트를 시작하고, `ssthresh(슬로 스타트 임곗값)`의 값을 `cwnd/2`로 정한다
- cwnd 값이 ssthresh와 같으면, 슬로 스타트는 종료되고 TCP는 혼잡 회피 모드로 전환한다

### 혼잡 회피
혼잡 회피 상태로 들어가는 시점에서 cwnd의 값은 대략 혼잡이 마지막으로 발견된 시점에서의 값의 반이 된다

새로운 승인이 도착할 때마다 TCP 송신자가 cwnd를 MSS바이트(MSS/cwnd)만큼 증가

혼잡 회피의 선형 증가가 언제 끝나는가?
- cwnd의 값은 1 MSS로 설정하고, ssthresh의 값은 손실 이벤트가 발생할 때 cwnd의 값의 반으로 설정한다
- 3개의 중복 ACK를 수신한 시점에서 cwnd의 값을 반으로 줄이고 ssthresh 값을 cwnd 값의 반으로 기록한 후 빠른 회복 상태로 들어간다

### 빠른 회복
**TCP 타호**인 초기 TCP는 손실이 발생하면 무조건 혼잡 윈도를 1 MSS로 줄이고 슬로 스타트 단계로 들어간다. ssthresh에 도달할 때까지 지수적으로 증가하며 이후에는 선형으로 증가한다

**TCP 리노**인 새로운 TCP는 손실이 발생하면 혼잡 윈도가 **모든 중복 ACK에 대해 1 MSS만큼씩 증가**하고 ssthresh 값은 손실 이벤트가 발생할 때의 cwnd의 값의 반으로 한다

### TCP 혼잡 제어: 복습
TCP 혼잡 제어는 RTT마다 1 MSS씩 cwnd의 선형 증가와 3개의 중복 ACK 이벤트에서 cwnd의 절반화로 구성되므로 **가법적 증가, 승법적 감소**의 혼잡 제어 형식이라고 불린다

TCP는 3개의 중복 ACK 이벤트가 발생할 때까지 선형으로 그 혼잡 윈도 크기를 증가시키고 혼잡 윈도 크기를 반으로 감소시키지만, 다시 추가적인 가용 대역폭이 있는지 탐색하기 위해 선형적으로 증가시키기 시작한다

### TCP 큐빅
TCP 큐빅은 패킷 손실이 발생한 혼잡한 링크의 상태가 많이 변경되지 않은 경우, 전송 속도를 더 빠르게 높여 손실 전 전송 속도에 근접한 다음 대역폭을 신중하게 조사한다

혼잡 손실이 발생하면 **혼잡 제어 윈도 크기에 가깝게 더 빠르게 증가**하여 혼잡 임곗값 바로 아래에서 가능한 한 오랫동안 흐름을 유지한다

### TCP 리노 처리율의 거시적 설명
장시간 연결된 TCP 연결의 평균 처리율은 `0.75 * W / RTT`이다

---
## 3.7.2 네트워크 지원 명시적 혼잡 알림과 지연 기반 혼잡 제어

### 명시적 혼잡 알림
명시적 혼잡 알림은 인터넷 내에서 수행되는 네트워크 지원 혼잡 제어의 한 형태로, TCP와 IP가 모두 관련되어 있다.
네트워크 계층에서 IP 데이터그램 헤더의 서비스 유형 필드에 있는 `2비트`가 `ECN`에 사용된다

`ECN 비트`의 한 설정은 라우터가 **정체를 겪고 있음**을 나타내기 위해 라우터에서 사용된다. 이 혼잡 표시는 표시된 IP 데이터그램에서 목적지 호스트로 전달되어 송신 호스트에게 알린다

두 번째 설정은 발신 호스트가 라우터에게 송신자와 수신자가 ECN을 사용할 수 있음을 알리고, 이에 따라 ECN으로 표시된 **네트워크 혼잡에 대한 응답**으로 조치를 취할 수 있음을 알린다

1. 수신 호스트의 TCP가 수신 데이터그램을 통해 ECN 혼잡 알림 표시를 수신
2. 수신 호스트의 TCP는 수신자-송신자 TCP ACK 세그먼트의 `ECE`비트를 설정하여 송신 호스트의 TCP에 혼잡 표시를 알린다
3. TCP 송신자는 **빠른 재전송**을 사용하여 손실된 세그먼트에 반응하는 것처럼 혼잡 윈도를 절반으로 줄여 혼잡 알림 표시가 있는 ACK에 반응하고 다음 전송되는 TCP 수신자 세그먼트 헤더에`CWR` 비트를 `1`로 설정한다

### 지연 기반 혼잡 제어
1. 혼잡해지는 라우터는 패킷들이 삭제되기 **전에**송신자에게 혼잡 알림 비트를 설정하여 송신자는 패킷 손실 **이전에** 더 일찍 전송 속도를 줄일 수 있으므로 패킷 손실 및 재전송을 피할 수 있다
2. 지연 기반 접근 방식을 취하여 패킷 손실이 발생하기 전에 혼잡 시작을 **사전에** 감지하는 것이다

`TCP 베가스`는 TCP 송신자가 파이프를 가득 채우되 그 이상으로 채우지 않도록 해야 한다

---
## 3.7.3 공평성
각 연결의 평균 전송률이 R/K에 가깝다면 혼잡 제어 메커니즘이 **공평**하다고 한다.
즉, 각 연결은 링크 대역폭을 동등하게 공유한다

클라이언트-서버 애플리케이션들은 링크 대역폭의 각기 다른 양을 얻을 수 있다.
