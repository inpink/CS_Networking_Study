# 웹과 HTTP
웹은 `온디맨드`방식으로 동작한다. 사용자가 원할 때 원하는 것을 수신한다. 

또한, 개인이 웹상에 어떠한 정보를 사용 가능하게 만드는 것이 매우 쉽다. 모든 사람이 매우 낮은 비용으로 발행자가 될 수 있다.

## 2.2.1 HTTP 개요
> 웹의 애플리케이션 계층 프로토콜인 `HTTP(HyperText Transfer Protocol)`는 웹의 중심이다.

HTTP는 **클라이언트 프로그램**과 **서버 프로그램**으로 구현된다.
각기 다른 종단 시스템에서 수행되는 클라이언트 프로그램과 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다.

### 웹 페이지(Web page)
> 웹 페이지는 객체들로 구성된다.

**객체(object)**는 단순히 단일 URL로 지정할 수 있는 하나의 파일이다.

대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 매체로 구성된다.

기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다.

각 URL은 2개의 요소, 즉 객체를 갖고 있는 서버의 호스트 이름과 객체의 경로 이름을 갖고 있다.

### 웹 브라우저(Web browser)와 웹 서버(Web server)
`웹 브라우저`는 `HTTP의 클라이언트` 측을 구현하기 때문에 웹 관점에서 브라우저와 클라이언트라는 용어를 혼용하여 사용한다.

브라우저는 요구한 웹 페이지를 보여주고 여러가지 인터넷 항해와 구성 특성을 제공한다.

`웹 서버`는 URL로 각각을 지정할 수 있는 웹 객체를 갖고 있다. 

HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다.

사용자가 웹 페이지를 요청할 때
- 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다
- 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다

### HTTP와 TCP
> HTTP는 TCP를 전송 프로토콜로 사용한다

1. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다
2. 연결이 이루어지면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다
3. 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP 응답 메시지를 받는다. HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.

HTTP는 데이터의 손실 또는 TCP가 어떻게 손실 데이터를 복구하고 네트워크 내부에서 데이터를 올바른 순서로 배열하는지 걱정할 필요가 없다. 
이는 **계층구조의 중요한 장점**이라고 볼 수 있다.

### 비상태 프로토콜(stateless protocol)
서버가 클라이언트에게 요청 파일을 보낼 때, 서버는 클라이언트에 관한 어떠한 상태 정보도 저장하지 않는다.

HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로, HTTP를 `비상태 프로토콜`이라고 한다.

---
## 2.2.2 비지속 연결과 지속 연결
각 요구/응답 쌍이 분리된 TCP 연결을 통해 보내져야 하는가? -> 비지속 연결

모든 요구와 해당하는 응답들이 같은 TCP 연결 상으로 보내져야 하는가? -> 지속 연결

### 비지속 연결 HTTP
HTTP는 클라이언트가 웹 페이지를 어떻게 해석하는지는 관심이 없다.

서버가 객체를 보낸 후에 `각 TCP 연결은 끊어진다`.

각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다.

브라우저는 여러 개의 TCP 연결을 설정하면서 다중 연결상에서 웹 페이지의 각기 다른 원하는 부분을 요청할 수도 있다.
동시 연결을 사용하면 응답 시간을 줄일 수 있다.

> `RTT(round-trip time)`: 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간
> RTT는 패킷 전파 지연, 중간 라우터와 스위치에서의 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다.

HTTP 파일을 요청하고 수신하는 데 걸리는 시간
- 브라우저가 브라우저와 웹 서버 사이에서 TCP 연결 시도, 세 방향 핸드셰이크(three-way handshake) 포함, 1 RTT 소요
- 클라이언트가 서버로 작은 TCP 메시지를 보내고, 서버는 작은 메시지로 응답하고, 마지막으로 클라이언트가 다시 서버에게 응답, 1 RTT 소요

총 응답 시간은 2 RTT와 HTML 파일을 서버가 전송하는 데 걸리는 시간의 합이다.

단점
- 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다
- 각 객체는 2 RTT를 필요로 한다

### 지속 연결 HTTP
HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 `TCP 연결을 그대로 유지`한다.

같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다.

객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다(`파이프라이닝(pipelining)`)

HTTP의 디폴트 모드는 파이프라이팅을 이용한 지속 연결을 사용한다.

---
## 2.2.3 HTTP 메시지 포맷
> HTTP 메시지에는 `요청 메시지`와 `응답 메시지`가 존재한다

### HTTP 요청 메시지
- 메시지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다
- 메시지가 다섯 줄로 되어있고 각 줄은 CR(carriage return)과 LF(line feed)로 구별된다

HTTP 요청 메시지의 첫 줄은 `요청 라인(request line)`이고, 이후의 줄들은 `헤더 라인(header line)`이다.

### 요청 라인
요청 라인은 방식(method)필드, URL 필드, HTTP 버전 필드, 3개의 필드를 갖는다.

방식 필드는 GET, POST, HEAD, PUT, DELETE 등의 여러 가지 값을 가질 수 있다.

### 헤더 라인
- Host: 헤더 라인은 객체가 존재하는 호스트를 명시한다. 호스트 헤더 라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다.
- Connection: 브라우저는 서버에게 지속 연결 사용을 원하는지, 비지속 연결 사용을 원하는지 명시한다.
- User-agent: 서버에게 요청을 하는 브라우저 타입을 명시한다. 서버가 같은 객체에 대한 다른 버전을 다른 타입의 사용자 에이전트에게 보낼 수 있으므로 유용하다
- Accept-language: 사용자가 객체의 원하는 버전을 명시한다. 존재하지 않으면 서버는 기본 버전을 보낸다.

### 개체 몸체
> GET일 때는 비어 있고(empty), POST 방식에서 사용된다

HTTP 클라이언트는 사용자가 폼을 채워 넣을 때(ex. 사용자가 검색 엔진에 검색 단어를 넣을 때), POST 방식을 사용한다

방식 필드의 값이 POST이면, 개체 몸체는 사용자가 폼 필드에 입력한 것을 포함한다

서버가 `HEAD 방식`을 가진 요청을 받으면 HTTP 메시지로 응답하는데, 요청 객체는 보내지 않는다

`PUT 방식`은 또한 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용된다

`DELETE 방식`은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다

### HTTP 응답 메시지
응답 메시지는 초기 `상태 라인(status line)`, 6개의 `헤더 라인`, `개체 몸체` 3개의 섹션으로 이루어졌다.

### 상태 라인과 상태 코드
상태 라인은 `버전 필드`, `상태 코드`, `해당 상태 메시지` 3개의 필드를 갖는다.

- 200 OK: 요청이 성공했고, 정보가 응답으로 보내졌다
- 301 Moved Permanently: 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location: 헤더에 나와 있다
- 400 Bad Request: 서버가 요청을 이해할 수 없다는 일반 오류 코드다
- 404 Not Found: 요청 문서가 서버에 존재하지 않는다
- 505 HTTP Version Not Supported: 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.

### 헤더 라인
- Connection: 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫을지 말지를 결정한다
- Date: HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다
- Server: 메시지가 어떤 웹 서버에 의해 만들어졌는지를 나타낸다
- Last-Modified: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다
- Content-Length: 송신되는 객체의 바이트 수를 나타낸다
- Content-Type: 객체 몸체 내부의 객체가 어떤 타입인지 나타낸다

---
## 2.2.4 사용자와 서버 간의 상호작용: 쿠키
HTTP 서버는 상태를 유지하지 않는다.

그러나, 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원하므로 웹사이트가 사용자를 확인하기 위해,
HTTP는 `쿠키(cookie)`를 사용한다.

쿠키는 사용자를 추적하게 해준다.

쿠키의 기술
- HTTP 응답 메시지 쿠키 헤더 라인
- HTTP 요청 메시지 쿠키 헤더 라인
- 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
- 웹사이트의 백엔드 데이터베이스

### 쿠키 동작 과정
1. 웹 서버에 HTTP 요청 메시지를 전달한다
2. 웹 서버는 유일한 식별번호를 만들고, 이 식별번호로 인덱싱되는 백엔드 데이터베이스 안에 엔트리를 만든다
3. HTTP 응답 메시지에 `Set-cookie: 식별번호`의 헤더를 포함해서 전달한다
4. 브라우저는 헤더를 보고, 관리하는 특정한 쿠키 파일에 그 라인을 덧붙인다
5. 다시 동일 웹 서버에 요청을 보낼 때, 브라우저는 쿠키 파일을 참조하고 이 사이트에 대한 식별번호를 발췌하여 `Cookie: 식별번호`의 헤더를 요청과 함께 보낸다

쿠키는 사용자 식별에 사용할 수 있다. 쿠키는 비상태 HTTP 위에서 사용자 세션 계층을 생성하는데 이용될 수 있다

---
## 2.2.5 웹 캐싱
> `웹 캐시(Web cache, proxy server)`는 기점 웹 서버(origin Web server)를 대신하여 HTTP 요구를 충족시키는 네트워크 개체다

웹 캐시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다

### 웹 캐시 동작 과정
1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 만약 저장되어 있다면, 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다
3. 만약 웹 캐시가 객체를 갖고 있지 않다면, 기점 서버로 TCP 연결을 설정한다. 이후 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다
4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 이미 설정된 TCP를 통해 객체의 사본을 보낸다

> 캐시는 서버이면서 클라이언트이다

웹 캐시는 ISP가 구입하고 설치한다

### 웹 캐싱의 사용 이유
- 웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
- 웹 캐시는 한 기관에서 인터넷으로의 접속하는 링크상의 웹 트래픽을 대폭으로 줄일 수 있다
- 인터넷 전체의 웹 트래픽을 실질적으로 줄임으로써 모든 애플리케이션을 위한 성능을 개선한다

`콘텐츠 전송 네트워크(Content Distribution Network, CDN)`의 사용을 통해, 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다

### 조건부 GET
> HTTP는 클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱을 하게 해주는 방식

HTTP 요청 메시지가 GET 방식을 사용하고, If-Modified-Since: 헤더 라인을 포함하고 있다면, 조건부 GET 메시지이다

### 조건부 GET 동작 과정
1. 브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보낸다
2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.
- 캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게 객체를 저장한다. 
- 중요한 것은 캐시가 객체와 더불어 마지막으로 수정된 날짜를 함께 저장한다.
3. 다른 브라우저가 같은 객체를 캐시에게 요청하면 캐시가 저장되어있다. 
- 이 객체는 지난주에 웹 서버에서 수정되었으므로 브라우저는 조건부 GET으로 갱신 조사를 수행한다.
- `If-modified-since`값이 일주일 전에 서버가 보낸 Last-Modified 값과 정확히 일치한다
- 이 조건부 GET은 서버에게 If-modified-since에 명시된 값 이후 수정된 경우에만 그 객체를 보내라고 한다
4. 변경되지 않았다면, 응답 메시지에 요청된 객체를 포함하지 않는다. 
- `304 Not Modified` 상태 라인을 갖고 있다
- 클라이언트에게 요청 객체의 캐싱된 복사본을 사용하라는 것을 의미한다

---
## 2.2.6 HTTP/2
HTTP/2의 주요 목표는 `하나의 TCP` 연결상에서 멀티플렉싱 요청/응답 지연 시간을 줄인다.

요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다.

HTTP/2는 상태 모드, URL, 헤더 필드 등 HTTP 메소드 자체는 변경하지 않았지만,
클라이언트와 서버 간의 데이터 포맷 방법과 전송 방법을 변경했다.

### 기존의 HTTP/1.1
웹 페이지당 오직 `하나의 TCP 연결`을 가짐으로써, 소켓 수를 줄이며 전송되는 각 웹 페이지는 공정한 네트워크 대역폭을 가질 수 있다.

그러나, 하나의 TCP상에서 웹 페이지에 있는 모든 객체를 보내면 `HOL(Head Of line) 블로킹`문제가 발생할 수 있다.
> HOL 블로킹 문제란 작은 객체들의 기다림이 길어져 앞쪽의 큰 객체가 작은 객체들을 블로킹한다.

HTTP/1.1 브라우저에서는 여러 개의 병렬 TCP 연결을 열어 HOL 블로킹 문제를 해결해왔다.

`TCP 혼잡 제어`는 각 TCP 연결이 공정하게 병목 링크를 공유하여 같은 크기의 가용한 대역폭을 공평하게 나누게 해준다.

### HTTP/2 프레이밍
HTTP/2의 주요 목표 중 하나는 하나의 웹 페이지를 전송하기 위한 병렬 TCP 연결의 수를 줄이거나 제거하는 것이다

> HTTP/2 프레이밍이란 각 메시지를 작은 프레임으로 나누고, 같은 TCP 연결에서의 요청과 응답 메시지를 인터리빙하고, 반대편 사이트에서 재조립하는 것이다

- 프레이밍은 HTTP/2 프로토콜의 프레임으로 구현된 다른 프레이밍 서브 계층에 의해 이루어진다
- 서버가 HTTP 응답을 보내고자 할 때, 응답은 프레이밍 서브 계층에 의해 처리되며 프레임들로 나눠진다
- 응답의 헤더 필드는 하나의 프레임이 되며, 메시지 본문은 하나의 프레임으로 쪼개진다
- 응답 프레임들은 서버의 프레이밍 서브 계층에 의해 인터리빙된 후, 하나의 지속적인 TCP 연결상에서 전송된다
- 프레임들이 클라이언트에 도착하면 프레이밍 서브 계층에서 처음 응답 메시지로 재조립되며 브라우저에 의해 처리된다
- 클라이언트의 HTTP 요청은 프레임으로 쪼개지고 인터리빙된다

### 메시지 우선순위화
> 메시지 우선순위화(message prioritization)은 개발자들이 요청들의 상대적 우선순위를 조정할 수 있게 함으로써 애플리케이션의 성능을 최적화할 수 있게 해준다

클라이언트가 하나의 특정 서버로 동시에 여러 개의 요청을 할 때, 각 메시지에 1~256 사이의 가중치를 부여함으로써 요청에 우선순위를 매긴다

서버는 가장 높은 우선순위의 요청을 위한 프레임을 제일 먼저 보낼 수 있다

### 서버 푸싱
> 서버가 특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 해준다

처음 요청에 대한 응답 외에도, 서버는 클라이언트의 요청 없이도 추가적인 객체를 클라이언트에게 `푸시`하여 보낼 수 있다

객체에 대한 HTTP 요청을 기다리는 대신 서버는 HTML 페이지를 분석할 수 있으며, 필요한 객체들을 식별할 수 있고,
해당 객체들에 대한 요청이 도착하기도 전에 해당 객체들을 클라이언트로 보낸다

### HTTP/3
HTTP/3은 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜

QUIC는 UDP 프로토콜 위에 위치하는 애플리케이션 계층에 구현되어 있다
