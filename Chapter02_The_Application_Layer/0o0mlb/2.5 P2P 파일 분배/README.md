# 2.5 P2P 파일 분배
> P2P 구조는 항상 켜져 있는 인프라스트럭처 서버에 최소한 의존하고, 간헐적으로 연결되는 `호스트 쌍`들이 서로 직접 통신한다

- 클라이언트-서버 파일 분배에서 서버는 파일 복사본을 각 피어들에게 보내야 한다
- 서버에게 커다란 부하를 주고 많은 양의 서버 대역폭을 소비한다
- P2P 파일 분배에서 각 피어는 수신한 파일의 임의의 부분을 다른 피어들에게 재분배할 수 있어서 서버의 분배 프로세스를 도울 수 있다

2020년에 가장 인기 있는 P2P 파일 분배 프로토콜은 `비트토렌트`다

### P2P 구조의 확장성
서버와 피어들은 접속 링크로 인터넷에 연결되어 있다
- 서버의 접속 링크 업로드 속도는 `u(s)`
- i번째 피어의 접속 링크 업로드 속도는 `u(i)`
- i번째 피어의 접속 링크 다운로드 속도는 `d(i)`
- 분배되는 파일의 크기는 `F bit`
- 파일의 복사본을 얻고자 하는 피어들의 수는 `N`

`분배 시간`은 모든 N개의 피어들이 파일의 복사본을 얻는 데 걸리는 시간이다.

### 클라이언트-서버 구조 분배 시간
- 서버는 파일 복사본을 N개의 피어 각각에게 전송해야 한다. 따라서 서버는 `NF 비트`를 전송해야 한다.
  - 즉, 서버가 파일을 분배하는 시간은 적어도 `NF/u(s)`이다
- d(min)이 가장 낮은 다운로드 속도를 가진 피어의 다운로드 속도를 나타낸다고 하자
  - 가장 낮은 다운로드 속도를 가진 피어는 `F/d(min)`초보다 적은 시간에 파일의 모든 `F비트`를 얻을 수 없다
  - 즉, 최소 분배 시간은 적어도 `F/d(min)`이다

분배 시간을 D(cs)라고 하면 다음과 같은 수식을 얻을 수 있다. 이는 최소 분배 시간의 하한값을 제공한다
```
D(cs) >= max{ NF/u(s), F/d(min) }
```
충분히 큰 N에 대해 클라이언트-서버 분배 시간은 `NF/u(s)`로 주어진다는 사실을 알 수 있다.

따라서, 분배 시간은 피어의 수 N에 따라 **선형적으로 증가**한다.

### P2P 구조 분배 시간
각 피어들이 서버가 파일을 분배하는 데 도움을 줄 수 있다.
특히, 한 피어가 파일 데이터 일부를 수신할 때, 피어는 그 데이터를 다른 피어들에게 재분배하는 데 자신의 업로드 용량을 이용할 수 있다.

- 분배가 시작되면 서버만이 파일을 갖고 있다.
  - 이 파일이 피어 커뮤니티에 도달할 수 있도록 하기 위해, 서버는 적어도 한 번 접속 링크로 파일의 각 비트를 보내야 한다
  - 즉, 최소 분배 시간은 적어도 `F/u(s)`이다
- 다운로드 속도가 낮은 피어는 `F/d(min)`초 보다 적은 시간 아네 파일의 모든 `F비트`를 얻을 수 없다
  - 즉, 최소 분배 시간은 적어도 `F/d(min)`이다
- 시스템의 전체 업로드 용량은 전체적으로 서버의 업로드 속도와 각 피어들의 업로드 속도를 더한 것이다. 즉, `u(total)`이다
  - 시스템은 N개 피어들 각각에게 `F비트`를 전달해야한다. 이는 `u(total)`보다 더 빠른 속도로 할 수 없다
  - 즉, 최소 분배 시간은 적어도 `NF/u(total)`이다

분배 시간을 D(p2p)라고 하면 다음과 같은 수식을 얻을 수 있다. 이는 최소 분배 시간에 대한 하한값을 제공한다
```
D(p2p) >= max{ F/u(s), F/d(min), NF/u(total) }
```
임의의 피어 수 N에 대해 클라이언트-서버 구조보다 P2P구조가 더 시간이 적다.
따라서 P2P 구조를 가진 애플리케이션은 `자가 확장성`을 갖는다.
이 확장성은 피어가 비트의 소비자이자 재분배자인 것의 직접적인 결과다

### 비트토렌트
> 비트토렌트는 파일 분배를 위한 인기있는 P2P 프로토콜이다

비트토렌트 용어로 특정 파일의 분배에 참여하는 모든 피어의 모임을 `토렌트(torrent)`라고 부른다

토렌트에 참여하는 피어들은 서로에게서 같은 크기의 `청크(chunk)`를 다운로드한다
- 피어가 처음으로 토렌트에 가입하면, 그 피어에는 청크가 없지만 시간이 지남에 따라 점점 많은 청크를 쌓을 수 있다
- 피어가 청크를 다운로드할 때 또한 청크를 다른 피어들에게 업로드한다
- 일단 한 피어가 전체 파일을 얻으면, 토렌트를 떠날 수 있거나 혹은 토렌트에 남아서 다른 피어들로 청크를 계속해서 업로드할 수 있다

각 토렌트는 `트래커(tracker)`라고 부르는 인프라스트럭처 노드를 갖고 있다
- 한 피어가 토렌트에 가입할 때 트래커에 자신을 등록하고 주기적으로 자신이 아직 토렌트에 있음을 알린다
- 트래커는 토렌트에 참여하는 피어들을 추척한다

### 비트토렌트의 파일 분배
새로운 피어 앨리스가 토렌트에 가입한다면

1. 트래커는 참여하고 있는 피어 집합에서 임의로 피어들의 부분집합을 선택하여 피어들의 IP주소를 앨리스에게 보낸다
2. 앨리스는 피어들의 목록에 있는 모든 피어와 동시에 `TCP 연결`을 설정한다. 앨리스가 성공적으로 TCP 연결을 설정한 모든 피어를 `이웃 피어`라고 부른다
3. 시간이 지남에 따라 이러한 피어들 중 일부는 떠나고 다른 피어들이 앨리스와 TCP 연결을 시도한다
4. 주기적으로 앨리스는 이웃 피어들 각각에게 (TCP 연결을 통해) 그들이 갖고 있는 청크 목록을 얻는다
5. 이를 바탕으로 앨리스는 지금 갖고 있지 않은 청크에 대해 (TCP 연결을 통해) 요구한다

### 가장 드문 것 먼저
앨리스는 두 가지 중요한 결정을 할 것이다
1. 이웃으로부터 어느 청크를 먼저 요구할 것인가?
2. 이웃들 중 어느 피어에게 청크를 요구할 것인가?

이때, `가장 드문 것 먼저(rarest first)`라는 기술을 사용한다.

앨리스가 갖고 있지 않은 청크 중에서, 이웃들 중 가장 적은 반복 복사본을 가진 청크를 결정하고 그 다음에 가장 드문 청크를 먼저 요구한다

이러한 방법으로 가장 드문 청크들은 더 빨리 재분배될 수 있어서 토렌트에 각 청크의 복사본 수가 대략적으로 동일해진다

### 현명한 교역
비트토렌트의 `현명한 교역(trading)` 알고리즘의 기본 아이디어는 앨리스가 가장 빠른 속도로 그녀에게 데이터를 제공하는 이웃에게 `우선순위`를 주는 것이다

- 특히, 계속해서 비트를 수신하는 속도를 측정하고 **가장 빠르게 전송하는 4개의 피어**를 결정한다
- 앨리스는 4개의 피어에게 청크를 보냄으로써 보답한다
- 그녀는 10초마다 속도를 재계산하고 4개의 피어 집합을 수정한다

비트토렌트 용어로 4개의 피어는 `활성화(unchoked)`되었다고 한다

- 30초마다 임의로 피어 하나를 추가로 선택하여 청크를 보낸다

비트토렌트 용어로 이 피어는 `낙관적으로 활성화(optimistically unchoked)`되었다고 한다

- 30초마다 앨리스는 임의로 새로운 교역 파트너를 선택하고 그 파트너와 교역을 시작한다. 이는 양립할 수 있는 속도로 업로드 할 능력을 가진 피어들이 서로 찾으려는 경향이 있다

5개의 피어 외의 모든 이웃 피어는 `비활성화(choked)`로 앨리스로부터 어떠한 청크도 받지 않는다

비트토렌트는 생태계는 매우 성공적이며, 수십만 개의 토렌트에서 동시에 수백만의 피어들이 능동적으로 파일을 공유하고 있다.
