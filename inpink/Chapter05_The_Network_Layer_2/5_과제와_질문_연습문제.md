# 과제와 질문 394p

R1. 라우팅 알고리즘이 각 라우터에서 실행됨을 의미한다.　   
하나의 각 라우터에는 제어 평면(라우팅 알고리즘, 소프트웨어)과 데이터 평면(포워딩, 하드웨어) 두 개가 들어있다.　   
각 라우터가 자체 제어 및 데이터 평면을 구현하는 독립적인 엔티티로 작동하기 때문에 네트워크 제어 및 데이터 평면이 단일하게 구현된다고 말한다.　   

　   
R2. 논리적으로 중앙 집중화된 제어란 논리적으로 중앙 집중화된 라우팅 컨트롤러가 각 라우터에서 사용할 포워딩 테이블을 계산하고 배포하는 것을 의미하며, 각 라우터는 라우터별 제어와 달리 포워딩 테이블을 계산하지 않는다.　   
논리적으로 중앙 집중식 제어의 경우, 데이터 평면과 제어 평면은 별도의 장치에 구현된다. 제어 평면은 중앙 서버 또는 여러 서버에 구현되고 데이터 평면은 각 라우터에 구현된다.　   

　   
R3. 
중앙 집중형 라우팅 알고리즘 : 네트워크 전체에 대한 완전한 정보를 가지고 있어야 함. 이를 이용하여 출발지와 목적지 사이의 최소 비용 경로를 계산. 전체적인 그림을 볼 수 있음. 링크 상태 알고리즘(다익스트라) 이용　   
분산 라우팅 알고리즘 : 최소 비용 경로의 계산이, "라우터들"에 의해 반복적이고 분산적으로 수행됨. 각 노드는 자신에게 직접 연결된 링크에 대한 비용 정보만 가지고 시작한다. 이 과정이 점차적으로 목적지까지 반복됨. 거리 벡터 알고리즘(벨만 포드) 이용　   

　   
R6. 
벨만-포드(Bellman-Ford) 알고리즘을 이용한다.　   
직접 연결된 이웃으로부터 정보를 받아 계산을 하고, 이 계산 결과를 이웃들에게 배포한다.　   

식은 다음과 같다.　   
dx(y)=minv{c(x,y)+dv(y)}　   
노드 x부터 y까지 최소 비용 경로의 비용이 dx(y)이다.　   

minv는 "x의 모든 이웃"에 적용된다.　   
x에서 v로 이동한 후, v에서 y까지의 최소 비용 경로를 선택한 것이다.　   
이들 중(모든 이웃 노드 v에 대해 바로 윗줄 계산), 가장 작은 값을 선택하게 된다. 　   

　   
R8. 거짓이다. OSPF는 "다익스트라 알고리즘"을 이용한다.　   
OSPF를 사용하면 라우터는 링크 상태 정보를 인접 라우터뿐만 아니라 자신이 속한 자율 시스템의 다른 모든 라우터로 "브로드캐스트"한다.　   
다익스트라 알고리즘 자체가, 전체 상태를 알고 있어야 하는 알고리즘이다.　   
각 라우터가 전체 AS의 완전한 토폴로지 맵을 구성한 다음, Dijkstra의 최단 경로 알고리즘을 로컬로 실행하여, **동일한 AS의 다른 모든 노드에 대한 최소 비용 경로를 결정해야 하기 때문**이다.　   

　   
R9. OSPF 자율 시스템(AS)에서의 영역(area)은, 라우터들의 집합을 의미한다.　   
이 영역 내에서, 각 라우터는 동일한 집합에 있는 다른 모든 라우터에 링크 상태를 "브로드캐스트"한다.　   
OSPF AS는 여러 영역으로 "계층적"으로 구성될 수 있다. 각 영역은 자체 OSPF 링크 상태 라우팅 알고리즘을 실행한다.　   
area의 개념은 확장성을 위해 도입되었다. 즉, 대규모 OSPF AS를 위한 계층적 라우팅을 구축하고자 사용된다.　   

　   
R10. 
서브넷 : 303p 그림 4.18를 참고하자. 큰 네트워크의 일부를 뜻한다.　   

주소 프리픽스 : 304p를 참고하자. IPv4 주소가 a.b.c.d/x 형식으로 작성될 때(x는 주소 첫 부분의 비트 수), "한 기관" 내의 여러 호스트들은 위 형식의 "하나의 주소 프리픽스"를 대표로 내세워 데이터를 받게 된다.　   
기간 내 호스트들은 보통 연속적인 주소를 할당받는다. 　   
223.1.1.0/24,  223.1.2.0/24,  223.1.3.0/24 이런 식으로.　   

이 모든 주소에 대해 라우터들이 포워딩 테이블을 만든다면, 크기가 매우 커지고 비효율적이다.　   
따라서, 공통 기관에 대해 "공통 프리픽스"를 둔다. 공통 프리픽스는 여러개 일수도 있다. "223.1.1.0/24는 모두 여기로 보내주세요" 라고 모두 받은 뒤, 기관 내에서 나눠서 데이터를 보내준다. 　   
 하나의 프리픽스는 하나 이상의 서브넷을 포함한다. 　   

BGP 경로 :　   
BGP는 ISP끼리의(AS간) 라우팅 프로토콜이다. 인터넷에 있는 수천 개의 ISP들을 연결하는 프로토콜이다.　   
BGP에서는 프리픽스로 패킷이 전달된다. 즉, BGP 경로는 프리픽스와, BGP 속성들을 말한다.　   

　   
R11. BGP 속성 중 중요한 두 가지가 AS-PATH와 NEXT-HOP이다. 　   
AS-PATH는 AS들을 담은 리스트이다. 경로를 선택할 때 사용하며, 메시지의 루프를 감지하고 방지하는 역할도 한다. 　   
NEXT-HOP은 AS-PATH가 시작되는 라우터 인터페이스의 IP 주소이다. 363p의 그림 5.10을 참고하자. 포워딩 테이블을 형성할 때 NEXT-HOP을 이용한다.　   
　   
　   
R14. 373p 그림 5.15를 참고하자.　   
통신 계층 : OpenFlow와 같은 프로토콜을 통해 'SDN 컨트롤러'와 '제어되는 네트워크 장치' 간의 통신을 담당한다.  이를 통해 'SDN 컨트롤러'는 장치를 제어하고, 장치는 관찰된 이벤트(링크 장애 등)를 'SDN 컨트롤러'에 전달한다.　   

네트워크 전체 상태 관리 계층 :  SDN로 제어되는 호스트, 링크, 스위치 등등의 장치 상태에 대한 최신 정보를 제공한다.(이 최신 정보를 제공해야, 전체적인 네트워크 내에 있는 다양한 제어 장치들의 플로우 테이블을 결정할 수 있다.) 컨트롤러는 또한 다양한 제어 장치의 플로우 테이블 복사본을 유지 관리하기도 한다.　   

네트워크 제어 애플리케이션 계층 : 'SDN 컨트롤러'는 '노스바운드 API(인터페이스)'를 통해 '네트워크 제어 애플리케이션(라우팅, 접속 제어, 로드 밸런서 등)'와 상호작용한다. 　   
이 계층을 통해 '네트워크 제어 애플리케이션'이 SDN의 다른 계층(통신,  전체 상태 관리)의 정보를 읽고 쓸 수 있게 한다.( 네트워크 상태 정보, 플로우 테이블 등)　   
　   
　   
R15.'네트워크 제어 애플리케이션'에 구현한다. 　   
　   
　   
R17. OpenFlow 프로토콜은 'SND 컨트롤러'의 '통신 계층'에서 사용되는 프로토콜로, SDN 컨트롤러와 장치(스위치, 라우터 등) 사이 데이터를 주고받는 통신을 위한 프로토콜(규약)이다.　   
1) SDN 컨트롤러-> 장치(스위치 등)　   
1-1) 설정 : 이 메세지는 컨트롤러가 장치의 설정 파라미터를 문의하거나 설정할 수 있다.　   
1-2) 패킷 전송 : 컨트롤러가 장치의 특정 포트에 특정 패킷을 전송할 수 있다. 　   

2) 장치 -> 컨트롤러　   
2-1) 플로우 제거 : 이 메세지는 장치가 컨트롤러에게 '어떤 플로우 테이블 엔트리가 시간이 만료되었음을 알리거나, 1) 중 "상태 수정" 메시지를 수신한 결과로 플로우 테이블이 삭제되었다고 알린다.　   
2-2) 패킷 전달 : 장치에 도착한 패킷 중, 플로우 테이블의 어떤 엔트리와도 일치하지 않는 패킷은, 처리를 위해 컨트롤러로 다시 전달된다. (4.4절 참고)　   
　   
　   


R18.  OpenDaylight SDN 컨트롤러의 '서비스 추상화 계층'에서는 다음과 같은 기능을 제공한다. 　   　   
"네트워크 서비스 애플리케이션" 내부에서 서로 통신할 수 있다. 컨트롤러 구성 요소와 응용 프로그램이 서로의 서비스를 호출하는 것이다.　  　    
또, OpenFlow, SNMP, NETCONF 등 통신 계층의 몇몇 기본 통신 프로토콜에 대한 통일된 추상 인터페이스를 제공한다.　   　   
　   
　   
R19. 
1) ICMP 경고 메시지(타입11, 코드0)
2) ping에 대한 에코 응답(0,0)
3) 목적지 네트워크 도달 불가능(3,0)
8) 에코 요청(8,0)
등
　   
　   

R21.　   
　   
1)관리 서버 : 네트워크 관리자와 상호작용하는 애플리케이션이다. 네트워크 관리자가 관리하며, 중앙 집중형 네트워크 관리 스테이션에 있다. 네트워크 관리 활동이 일어난다. 네트워크 관리 정보의 수집, 처리, 분석, 발송 등의 행동을 한다.　   
하나의 네트워크에서 여러 개의 관리 서버가 있을 수 있다.　   

2)피관리 장치 : 네트워크에 존재하는 모든 네트워크 장비(소프트웨어 포함)을 뜻한다.
　   
　   
3) 네트워크 관리 에이전트 : 피관리 장치에 있는 "소프트웨어 프로세스"를 뜻한다.
　   
　   

R22.
GetRequest는 네트워크 관리자 -> 에이전트 보내는 것으로, "하나 또는 그 이상의 MIB 객체 인스턴스의 값을 가져온다"　   
SetRequest는 네트워크 관리자 -> 에이전트 보내는 것으로, "하나 또는 그 이상의 MIB 객체 인스턴스의 값을 설정한다"　   
　   
　   

R23.
네트워크 에이전트가 무언가를 명령받지 않더라도, "트랩 메시지"라는 메시지를 "관리 서버"에 전송한다. 에이전트가 명령받지 않고도 MIB 객체 값을 변화시킨 예외 상황(링크 인터페이스의 활성화 등)을 통지하기 위해 사용한다.
