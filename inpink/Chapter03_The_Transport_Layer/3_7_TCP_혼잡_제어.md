> 목차

👉[3.7 TCP 혼잡 제어](#37-TCP-혼잡-제어)　   

　   
　   
## 3.7 TCP 혼잡 제어

이번 절에서는 "전통적인 TCP 혼잡제어"에 대해 알아본다.　   
　   
전통적인 TCP 혼잡제어에서는, 　   
**IP 계층이 네트워크 혼잡에 대해 종단 시스템에게 어떠한 직접적인 피드백을 제공하지 않기** 때문에　   
3.6절에서 배웠던 "1) 종단 간의 혼잡제어" 방식을 이용한다. 　   
　   
경로에서 혼잡이 감지되지 않으면 **송신자는 "송신율"을 높인다**　   
혼잡이 감지되면, 송신율을 줄인다.　   
　   
~~~
LastByteSent - LastByteAcked <= min(cwnd, rwnd)
~~~
rwnd는 3.5.5절에서 배운 내용이다. "버퍼의 여유 공간"으로 설정되는 "수신 윈도 크기"이다.　   
cwnd는 **혼잡 윈도(congestion window)**이다.　   
=> 송신자가 "ACK받지 않아도 보낼 수 있는 데이터의 양"은 cwnd와 rwnd의 최솟값을 넘지 않는다.　   
　   
아래에서는 네트워크 혼잡 상황에 따라 "혼잡 윈도"가 어떻게 변하는지 알아본다.　   
위에서도 언급했듯, 혼잡 윈도는 송신자가 "ACK받지 않아도 보낼 수 있는 데이터의 양"과 관련이 있다.　   
송신자가 직접 네트워크 상황을 보며 설정해준다.　   
　   
　   
> TCP 혼잡 제어 알고리즘(TCP congestion-control algorithm)

매우 유명한 TCP의 3가지 혼잡 제어 알고리즘이다.　   
1) 느린 시작(slow start)　   
2) 혼잡 회피(congestion avoidance)　   
3) 빠른 회복(fast recovery)　   
=> 1,2번은 TCP의 필수이다. 3번은 필수는 아니다.　   
　   
　   
> 1) 느린 시작(slow start)

TCP 연결이 시작될 때 cwnd(혼잡 윈도)의 값은 1MSS으로 시작한다.　   
확인 응답(ACK)를 1개 받을 때마다 1MSS씩 증가한다.　   
=> 처음엔 느리게 시작했다가, ACK 수에 따라 최대 혼잡 윈도값을 늘리며 전송률을 높일 수 있다.　   
　   
만약 혼잡이 발생했을 경우(혼잡 윈도값에 다다름 또는 타임아웃 발생)　   
**cwnd값을 1로 바꾸고, 새로운 느린 시작을 시작한다. 　   
ssthresh(slow start threshold, 느린 시작 임계값)을 cwnd/2으로 정한다!**　   
　   
ssthresh값은, 혼잡이 한 번 생긴 뒤에 생기게 된다.　    
혼잡이 생겼으므로 최대 전송률을 더 낮게 설명해주는 것이다.　   
　   
　   
> 2) 혼잡 회피(congestion avoidance)

ssthresh값이 설정된 상태에서, ssthresh값게 도달하면 , TCP는 **혼잡 회피** 모드로 전환된다.　   
이미 혼잡하여 ssthresh값을 cwnd의 반으로 정해주었는데도 또 혼잡에 도달했기 때문에　   
혼잡 회피 모드에서 cwnd를 더욱 조심스럽게 증가시켜줘야 한다.　   
　   
혼잡 회피 모드는 다양한 방식으로 구현될 수 있다.　   
예) 각 ACK마다 1/10MSS만큼 혼잡 윈도우 증가　   
　   
　   
> 3) 빠른 회복(fast recovery)

**빠른 회복**또한 다양한 구현 방법이 있다.　   
말 그대로, TCP의 빠른 회복을 위한 방법이다.　   
　   
예를 들어 중복된 ACK가 3개(116번)가 도착했다고 해보자. 　   
송신자는 마지막으로 도착한 ACK(116번)의 다음 것(117번)을 보내주면 되고, 그 다다음 3가지(118,119,120)는 이미 잘 도착했다는 것을 간접적으로 알 수 있다. 　   
따라서, **중복된 ACK만큼 1MSS씩 증가시킨다** (총 3 증가)　   
그리고, 손실된 ACK(117번)이 도착하면, "혼잡 회피 모드"로 전환시킨다.　   
