# 4.2 라우터 내부에는 무엇이 있을까?
라우터의 4가지 요소는 다음과 같다

1. 입력 포트
- 입력 포트의 맨 왼쪽 박스와 출력 포트의 맨 오른쪽 박스는 라우터로 들어오는 입력 링크로, 물리 계층 기능을 수행한다
- 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능을 수행한다. 이는 미들박스로 표시된다
- **검색 기능**을 수행한다. 가장 오른쪽 박스에서 발생하고 `포워딩 테이블`을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정한다
- 제어 패킷은 입력 포트에서 `라우팅 프로세서`로 전달된다
2. 스위치 구조
- 스위치 구조는 입력 포트와 출력 포트를 연결한다
- 라우터 내부에 포함되어 있다
3. 출력 포트
- 스위치 구조에서 수신한 패킷을 저장하고 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷을 전송한다
4. 라우팅 프로세서
- 제어 평면 기능을 수행한다
- `기존 라우터`는 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하여 라우팅의 포워딩 테이블을 계산한다
- `SDN 라우터`는 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 입력 포트에 이러한 엔트리를 설치한다

라우터로 진입하기 전에 절차는 다음과 같다

- 목적지 기반 포워딩: 최종 목적지를 검색하여 연결되는 출력 포트를 결정한다
- 일반화된 포워딩: 패킷에 대한 많은 요인이 출력 포트를 결정한다

## 4.2.1 입력 포트 처리 및 목적지 기반 전송
1. 입력 포트의 라인 종단
2. 라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층 처리
3. 라우터 동작
3-1. 포워딩 테이블을 사용하여 도착 패킷이 전달되는 출력 포트를 검색
3-2. 포워딩 테이블은 라우팅 프로세서에서 입력 라인 카드로 복사된다

### 입력 패킷을 출력 포트로 스위칭
포워딩 테이블에서 라우터는 패킷의 목적지 주소의 **프리픽스(prefix)**를 테이블의 엔트리와 매치한다

매치되는 엔트리가 존재하면, 라우터는 패킷을 그 매치에 연관된 링크로 보낸다

다수의 매치가 있을 때, 라우터는 **최장 프리픽스 매치 규칙**을 사용한다

포워딩 테이블에서의 검색은 빠른 메모리 접속 시간이 필요하므로, 내장형 DRAM과 빠른 SRAM 메모리가 필요하다

### 패킷을 스위치 구조로 전달
검색을 통해 패킷의 출력 포트가 결정되면 패킷을 `스위치 구조`로 보낸다

만약, 다른 입력 포트로부터 패킷이 현재 구조를 사용하고 있다면 일시적으로 차단할 수 있다. **차단된 패킷**은 입력 포트에 대기한 다음 나중에 구조를 **교체하도록 예약**된다

---
## 4.2.2 스위칭
스위치 구조는 패킷이 입력 포트에서 출력 포트로 실제로 `스위칭(포워딩)`되는 구조를 통과하므로 라우터의 핵심이다

스위칭의 여러 가지 방법은 다음과 같다

- 메모리를 통한 교환

1. 패킷이 도착하면 입력 포트는 라우팅 프로세서에게 `인터럽트`를 보내 패킷을 프로세서 메모리에 복사한다
2. 라우팅 프로세서는 헤더에게 `목적지 주소`를 추출하고 포워딩 테이블에서 적절한 출력 포트를 찾는다
3. 라우팅 프로세서는 패킷을 `출력 포트의 버퍼`에 복사한다

최근 라우터는 목적지 주소를 검색하고 해당 메모리 위치에 패킷을 저장하는 것이 `입력 라인 카드`에서 처리한다. 라인 카드에서 패킷을 처리하여 적절한 출력 포트의 메모리로 스위칭(쓰기)한다

- 버스를 통한 교환

입력 포트는 **라우팅 프로세서의 개입 없이** 공유 버스를 통해 직접 출력 포트로 패킷을 전송한다. 미리 준비된 입력 포트 스위치 내부 레이블이 패킷에게 전송된다

모든 출력 포트에 패킷이 수신되지만 레이블과 매치되는 포트만 패킷을 유지한다. 레이블은 출력 포트에서 제거된다

한 번에 하나의 패킷만 버스를 통과할 수 있다

- 상호연결 네트워크를 통한 교환

`크로스바 스위치`는 N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호연결 네트워크이다.
이는 여러 패킷을 **병렬**로 전달할 수 있다

---
## 4.2.3 출력 포트 처리
출력 포트 처리는 출력 포트의 메모리에 저장된 패킷을 가져와 출력 링크를 통해 전송한다. 여기에는 `전송을 위한 패킷 선택(스케줄링)`, `큐 제거`, `필요한 링크 계층 및 물리 계층 전송`을 수행하는 것이 포함된다

---
## 4.2.4 어디에서 큐잉이 일어날까?
패킷 큐는 입력 포트와 출력 포트 모두에서 형성될 수 있다

큐가 더 커지면 라우터의 메모리가 결국 소모될 수 있고 도착하는 패킷을 저장할 수 있는 메모리가 없을 때 **패킷 손실**이 발생한다

### 입력 큐잉
크로스바 스위치 구조는 다음과 같다
1. 모든 링크의 속도는 같다
2. 입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달한다
3. FCFS 방식으로 패킷은 입력 큐에서 출력 큐로 이동된다

스위치 구조는 **한 번에 하나의 패킷만** 지정된 출력 포트로 전송이 가능하다.

라인의 앞쪽에서 다른 패킷이 막고 있는 경우 입력 큐에서 대기 중인 패킷은 **사용할 출력 포트가 사용 중이지 않아도** 스위치 구조를 통해 전송되기 위해 기다리므로, 입력 대기 중인 스위치에서 `HOL 차단(블로킹)` 현상이라고 한다

### 출력 큐잉
출력 포트는 시간 단위에 **단일 패킷만** 전송할 수 있기 때문에 대기 중인 패킷의 수가 출력 포트에서 사용 가능한 메모리를 다 소모할 만큼 많아질 수 있다

들어오는 패킷을 저장할 메모리가 충분하지 않을 때 **도착한 패킷을 삭제(drop-tail)**하거나 이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간을 확보한다

버퍼가 가득 차기 **전에** 패킷을 삭제하거나 헤더를 마킹하여 혼잡 신호를 제공한다. 이 마킹은 `명시적 혼잡 알림` 비트를 사용하여 수행한다

**AOM** 알고리즘은 `패킷 삭제`와 `패킷 마킹`을 분석한다. 

큐잉의 결과 출력 포트의 **패킷 스케줄러**가 전송 대기 중인 패킷 중 하나의 패킷을 선택한다

### 얼마나 많은 버퍼가 요구되는가?
버퍼링이 트래픽의 단기 통계 변동을 흡수하는 데 사용될 수 있지만 지연을 증가시킬 수 있다.
따라서 버퍼링은 적당해야 한다

지속적 버퍼링으로 인한 지연에 대한 시나리오를 **버퍼블로트**라고 하는데, 이는 처리량뿐만 아니라 최소 지연도 중요하고 네트워크 가장자리와 네트워크 내 큐에서 송신자 간의 상호 작용이 실제로 복잡하고 미묘할 수 있음을 보여준다

---
## 4.2.5 패킷 스케줄링

### FIFO
`FIFO(FCFS) 스케줄링` 규칙은 출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택한다

### 우선순위 큐잉
출력 링크로 도착한 패킷들은 **우선순위 클래스**로 분류되며, 전송할 패킷을 선택할 때 `우선순위 큐`는 전송 대기 중인 패킷으로 차 있는 상태이고 가장 높은 우선순위 클래스에서 패킷을 전송한다

우선순위가 동일한 패킷들은 FIFO 방식으로 전송된다

`비선점 우선순위 큐잉`에서는 패킷의 전송이 시작되면 **중단하지 않으므로** 우선순위가 더 높은 패킷이 도착하더라도 대기한다

### 라운드 로빈과 WFQ
`라운드 로빈 큐잉` 규칙에서 패킷은 클래스로 분류되지만 엄격한 우선순위가 존재하지 않고, 클래스 간에 서비스를 번갈아서 제공한다

**작업 보존 큐잉** 규칙의 경우, 전송을 위해 큐에서 기다리는 패킷이 있는데 빈 클래스 큐를 찾으면, 링크는 시퀀스의 다음 클래스를 즉시 검사한다

`WFQ`는 라운드 로빈 큐잉의 일반화된 형태로 **각 클래스마다 다른 양의 서비스 시간**을 부여받는 다는 점에서 차이가 있다
