# 5.2 라우팅 알고리즘
라우팅 알고리즘의 목표는 송신자로부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로(최소 비용 경로)를 결정하는 것이다

**그래프**는 G(N, E)로 나타내고, N과 E는 각각 노드와 엣지의 집합이고, 하나의 엣지는 집합 N에 속하는 한 쌍의 노드로 표시된다

노드는 패킷 전달 결정이 이루어지는 지점인 **라우터**를 나타내며, 엣지는 라우터들 간의 **물리 링크**를 나타낸다

c(x, y): 노드 x와 y 간의 비용을 의미한다

(x, y)가 E에 속하면, 노드 y는 노드 x의 **이웃**이라고 한다

두 노드 x, y가 주어지면 일반적으로 많은 경로가 존재하는데, **최소 비용 경로**는 하나 이상이다.

라우팅 알고리즘을 분류하는 방법은 다음과 같다

1. 중앙 집중형 vs 분산형
- 중앙 집중형 라우팅 알고리즘: **네트워크 전체에 대한 완전한 정보**를 가지고 출발지와 목적지 사이의 최소 비용 경로를 계산한다. 전체 상태 정보를 갖는 알고리즘을 `링크 상태 알고리즘`이라 한다
- 분산 라우팅 알고리즘: 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다. **반복된 계산과 이웃 노드와의 정보 교환**을 통해 최소 비용 경로를 계산한다. 이는 `거리 벡터 알고리즘`이라 한다

2. 정적 vs 동적
- 정적 라우팅 알고리즘: 사람의 개입에 의해 라우팅 경로를 바꾼다
- 동적 라우팅 알고리즘: 네트워크 트래픽 부하나 토폴로지 변화에 의해 라우팅 경로를 바꾼다

3. 부하에 민감 여부
- 부하에 민감한 알고리즘: 링크 비용이 현재 혼잡 수준을 나타내기 위해 동적으로 변한다
- 부하에 민감하지 않은 알고리즘: 링크 비용이 현재 혼잡을 반영하지 않는다

## 5.2.1 링크 상태(LS) 라우팅 알고리즘
링크 상태 알고리즘은 네트워크 토폴로지와 모든 링크 비용이 알려져 있어 링크 상태 알고리즘의 입력값으로 사용될 수 있다.

각 노드가 링크 상태 패킷을 네트워크 상의 다른 **모든** 노드로 브로드캐스트함으로써 가능하다

### 다익스트라 알고리즘
다익스트라 알고리즘은 하나의 노드에서 네트워크 내 다른 모든 노드로의 최소 비용 경로를 계산한다

1. 출발지 노드로 직접 연결된 이웃까지의 현재 알려진 최소 비용 경로를 초기화한다
2. N' 집합에 포함되지 않은 노드 중 최소 비용을 갖는 노드를 N'에 추가하고 경로 비용을 갱신한다
3. 2번을 반복한다

종료된 후에 각 노드에 대해 출발지 노드로부터 최소 비용 경로상의 직전 노드를 알게 되고, 이를 통해 출발지에서 모든 목적지까지의 전체 경로를 구축할 수 있다

---
## 5.2.2 거리 벡터(DV) 라우팅 알고리즘
거리 벡터 알고리즘은 반복적이고 비동기적이며 분산적이다


각 노드는 하나 이상의 **직접 연결된** 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 그 이웃들에게 배포한다는 점에서 **분산적**이고, 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다는 점에서는 **반복적**이고, 모든 노드가 서로 정확히 맞물려 동작할 필요가 없다는 점에서 **비동기적**이다


노드 x부터 y까지 최소 비용 경로의 비용은 `벨만포드 식`으로 나타낼 수 있다


거리 벡터 라우팅 알고리즘의 기본 아이디어는 출발지 노드를 x라고 가정하면, 노드 x는 자신으로부터 집합 N에 속한 다른 모든 노드 y까지의 최소 비용 경로의 비용 D.x(y)를 추정한다

1. 각 노드는 이웃으로부터의 갱신을 기다린다
2. 업데이터를 수신하면 새로 거리 벡터를 계산한다
3. 이 새로운 거리 벡터를 이웃들에게 배포한다

이 과정을 더 이상의 갱신 메시지가 없을 때까지 반복한다

### 거리 벡터(DV) 알고리즘: 링크 비용 변경과 링크 고장
DV 알고리즘을 수행하는 노드가
1. 자신과 이웃 사이 링크의 비용이 변경된 것을 알게 되면
2. 자신의 거리 벡터를 갱신한 후
3. **최소 비용 경로의 변화가 있는 경우**에는 이웃에게 새로운 거리 벡터를 보낸다

case 1. 비용이 감소할 때

거리 벡터 알고리즘은 정지 상태가 될 때까지 2번만 반복하면 된다

case 2. 비용이 증가할 때

우리는 네트워크 전체를 한눈에 볼 수 있기 때문에 비용이 잘못되었다는 사실을 알지만, 노드는 모르기 때문에 `라우팅 루프`가 발생한다

이는 새로운 최소 비용 계산을 반복하여 `무한 계수 문제`라고 부른다

### 거리 벡터 알고리즘: 포이즌 리버스 추가
특정한 라우팅 루프 문제는 `포이즌 리버스` 방법을 통해 방지가 가능하다

만약 z가 y를 통해 목적지 x로 가는 경로 설정을 했다면, **z는 y에게 x까지의 거리가 무한대**라고 알린다

하지만, 포이즌 리버스는 모든 무한 계수 문제를 해결할 수는 없다

### 링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교
`LS 알고리즘`
- 전체 정보를 필요로 하고, 각 노드는 다른 모든 노드와 오직 자신에게 직접 연결된 링크의 비용만 알린다
- 링크 비용이 변할 때마다 새로운 링크 비용이 모든 노드에게 전달되어야 한다
- 라우터는 연결된 링크에 대해 잘못된 비용 정보를 브로드캐스트할 수 있지만, 노드는 링크 상태 브로드캐스트를 통해 받은 패킷을 변질시키거나 폐기할 수 있다

`DV 알고리즘`
- 각 노드는 오직 직접 연결된 이웃과만 메시지를 교환하고, 자신으로부터 네트워크 내 모든 노드로의 최소 비용 추정값을 이웃들에게 제공한다
- 매번 반복마다 직접 연결된 이웃끼리 메시지를 교환한다
- 노드는 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에게 알릴 수 있어, 전체로 확산될 수 있다
